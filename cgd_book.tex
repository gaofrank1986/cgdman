\documentclass[oneside,12pt]{cgd_book}
\usepackage[T1]{fontenc}
\pagestyle{heading}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{array}
\usepackage{varioref}
\usepackage{refstyle}
\usepackage{float}
\usepackage{booktabs}
\usepackage{calc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{esint}
\usepackage{nameref}
\usepackage{longtable}
\usepackage{siunitx}

\makeindex
\begin{document}

\productTitle{Genius}
\productSubtitle{Semiconductor Device Simulator}
\productVersion{Version 1.7.4}
\title{Genius User\textquoteright s Guide}
\company{Cgenda Pte Ltd}

\maketitle
\clearpage{}

\thispagestyle{empty}

Copyright (c) 2008-2009 Cogenda Pte Ltd, Singapore.

All rights reserved.

\marginhead{License Grant}Duplication of this documentation is permitted
only for internal use within the organization of the licensee.

\marginhead{Disclaimer}THIS DOCUMENTATION IS PROVIDED BY THE COPYRIGHT
HOLDERS AND CONTRIBUTORS \textquotedbl{}AS IS\textquotedbl{} AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

\vfill{}


This documentation was typed in DocBook XML format, and typeset with
the Lyx program. We sincerely thank the contributors of the two projects,
for their excellent work as well as their generoisty.

\newpage{}

\tableofcontents{}


\chapter{Physics in Genius Device Simulator}

Since Gummel's original work, the drift-diffusion model has been widely used in the semiconductor device
    simulation. It is now the de facto industry standard in this field.
\par
The original DD model can be achieved by following approximation from hydrodynamic model:
\begin{compactitem}
\item Light speed is much faster than carrier speed.
\par
\item All the collision is elastic.
\par
\item Bandgap does not change during collision.
\par
\item Carrier temperature equals to lattice temperature and keeps equilibrium.
\par
\item The gradient of driving force should keep small.
\par
\item Carrier degenerate can be neglected.
\par
\end{compactitem}
\par
Some improvements have been applied to DD model for extend its capability. These "patches" of course make
    things complex, but they can deal with real problems.
\par
This chapter describes the DD model and its variations used by GENIUS code for describing semiconductor device
    behavior as well as physical based parameters such as mobility, recombination rate and son on.
\par
\section{Level 1 Drift-Diffusion Equation}
\label{sec:Equation:DDML1}
Level 1 Drift-Diffusion ($\mathbf{DDML1}$) \index{DDML1!Equation}is the fundamental solver of GENIUS code for lattice temperature keeps constant though out the solve
      procedure.
\par
The primary function of $\mathbf{DDML1}$ is to solve the following set of partial differential
      equations, namely Poisson's equation, along with the hole and electron continuity equations:
\par
\marginhead{Poisson's Equation}
\begin{equation}
\nabla \cdot \varepsilon \nabla \psi = - q\left( p - n + {N_D}^+ - {N_A}^- \right)
\end{equation}
\par
\par
\index{Poisson's Equation}where, $\psi$ is the electrostatic potential of the vacuum level. This
      choice makes the description of metal-oxide-semiconductor contact and heterojunction easier.
$n$ and $p$ are the electron and hole concentration, ${N_D}^{+}$
and ${N_A}^{-}$ are the ionized impurity
      concentrations. $q$ is the magnitude of the charge of an electron.
\par
The relationship of conduct band $E_c$, valence band $E_v$ and vacuum level
$\psi$ is:
\begin{subequations}
\begin{align}
 E_c  =-q\psi-\chi-\Delta E_c \\
 E_v  =E_c-E_g+\Delta E_v.
\end{align}
\end{subequations}
\par
Here, $\chi$ is the electron affinity. $E_g$ is the
      bandgap of semiconductor. $\Delta E_c$ and $\Delta E_v$ are the bandgap shift caused by heavy doping or mechanical strain.
\par
Furthermore, the relationship of vacuum level $\psi$ and intrinsic Fermi
      potential $\psi_ {\rm intrinsic}$ is:
\begin{equation}
\psi = \psi _{\rm intrinsic} - \frac{\chi}{q} - \frac{E_g}{2q} - \frac{k_b T}{2q}\ln \left(
          \frac{N_c}{N_v} \right)
\end{equation}
\par
The reference $0\eVolt$ of energy is set to intrinsic Fermi level of equilibrium
      state in GENIUS.
\par
\marginhead{Continuity Equations}\index{Continuity equation!DDML1}The continuity equations for electrons and holes are defined as follows:
\par
\par
\begin{subequations}
\begin{align}
 \frac{\partial n}{\partial t}  = \frac{1}{q}\nabla \cdot \vec{J}_n - (U - G) \\
 \frac{\partial p}{\partial t}  = - \frac{1}{q}\nabla \cdot \vec{J}_p - (U - G)
\end{align}
\end{subequations}
where $\vec{J}_n$ and $\vec{J}_p$ are the electron
      and hole current densities, $U$ and $G$ are the
      recombination and generation rates for both electrons and holes.
\par
\marginhead{Drift-Diffusion Current Equations}\index{Drift-diffusion current!DDML1}The current densities
$\vec{J}_n$ and $\vec{J}_p$ are expressed in terms of the level 1 drift-diffusion model here.
\par
\par
\begin{subequations}
\label{eq:Equation:DDML1:DDMCurrent}
\begin{align}
 \vec{J}_n  = q\mu_n n \vec{E}_n + q D_n \nabla n \\
 \vec{J}_p  = q\mu_p p \vec{E}_p - q D_p \nabla p
\end{align}
\end{subequations}
where $\mu_n$ and $\mu_p$ are the
      electron and hole mobilities. $D_n=\frac{k_bT}{q}\mu_n$ and
$D_p=\frac{k_bT}{q}\mu_p$ are the electron and hole diffusivities, according to Einstein
      relationship.
\par
\marginhead{Effective Electrical Field}$\vec{E}_n$ and $\vec{E}_p$
are the effective
        driving electrical field to electrons and holes, which related to local band diagram. The band structure of
        heterojunction has been taken into account here \cite[Lindefelt1994]{}.
\par
\par
\begin{subequations}
\label{eq:Equation:DDML1:DrivingField}
\begin{align}
 \vec{E}_n  = \frac{1}{q}\nabla E_c - \frac{k_b T}{q}\nabla \left( \ln (N_c ) - \ln (T^{3/2} )
        \right) \\
 \vec{E}_p  = \frac{1}{q}\nabla E_v + \frac{k_b T}{q}\nabla \left( \ln (N_v ) - \ln (T^{3/2} )
        \right)
\end{align}
\end{subequations}
The lattice temperature keeps uniform throughout $\mathbf{DDML1}$, the above temperature
      gradient item takes no effect in fact.
\par
By substituting drift-diffusion model into the current density expressions, and combining with Poisson's
      equation, the following basic equations for $\mathbf{DDML1}$
are obtained:
\par
\begin{subequations}
\begin{align}
 \frac{\partial n}{\partial t}  = \nabla \cdot \left (\mu_n n \vec{E}_n + \mu_n\frac{k_b T}{q}\nabla n \right
        ) - (U - G) \\
 \frac{\partial p}{\partial t}  = -\nabla \cdot \left (\mu_p p\vec{E}_p - \mu_p\frac{k_b T}{q}\nabla p \right
        ) - (U - G)  \\
 \nabla \cdot \varepsilon \nabla \psi  = - q(p - n + {N_D}^{+} - {N_A}^{-} )
\end{align}
\end{subequations}
$\mathbf{DDML1}$ is suitable for PN diode, BJT transistor and long gate MOSFET simulation. It is
      robust, and runs pretty fast for real work. The detailed discretization scheme can be found at [[TODO]].
\par
\section{Level 2 Drift-Diffusion Equation}
\label{sec:Equation:DDML2}
\index{DDML2!Equation}The Level 2 DD model considers the influence of lattice temperature by solving the extra thermal
      equation simultaneously with the electrical equations. Also, the formula of drift-diffusion equation should be
      modified according to \cite[Selberherr1984]{}.
\par
\index{Drift-diffusion current!DDML2}The electron diffusion current in
$\mathbf{DDML1}$ can be written as:
\par
\begin{equation}
{\vec{J}}_{n,{\rm diff}} = \frac{k_b T}{q}\mu_n q\nabla n = k_b T\mu_n \nabla n
\end{equation}
\marginhead{Temperature Gradient Correction}But for DDML2, it has the form of
\par
\par
\begin{equation}
{\vec{J}}_{n,{\rm diff}} = \mu_n k_b (T\nabla n + n\nabla T)
\end{equation}
The hole diffusion current should be modified in the same manner.
\par
\begin{equation}
{\vec{J}}_{p,{\rm diff}} = -\mu_p k_b (T\nabla p + p\nabla T)
\end{equation}
\marginhead{Heat Flow Equation}\index{Heat flow equation!DDML2}The following heat flow equation is used:
\par
\par
\begin{equation}
\rho c_p \frac{\partial T}{\partial t} = \nabla \cdot \kappa \nabla T + \vec{J} \cdot \vec{E} + (E_g + 3k_b T) \cdot
        (U - G)
\end{equation}
where $\rho$ is the mass density of semiconductor material. $c_p$
is the heat capacity. $\kappa$ is the thermal conductivity
      of the material. $\vec{J}\cdot\vec{E}$ is the joule heating of current.
$(E_g + 3k_b T) \cdot (U - G)$ is lattice heating due to carrier recombination and
      generation.
\par
From above discussion, the governing equations for DDML2 are as follows:
\par
\begin{subequations}
\begin{align}
 \frac{\partial n}{\partial t}  = \nabla \cdot \left(\mu_n n \vec{E}_n + \mu_n \frac{k_b T}{q}\nabla n + \mu_n
        \frac{k_b \nabla T}{q} n\right) - \left( {U - G} \right) \\
 \frac{\partial p}{\partial t}  = -\nabla \cdot \left(\mu_p p \vec{E}_p - \mu_p \frac{k_b T}{q}\nabla p -
        \mu_p \frac{k_b \nabla T}{q} p\right) - \left( {U - G} \right) \\
 \nabla \cdot \varepsilon \nabla \psi  = - q\left( {p - n + {N_D}^+ - {N_A}^ - } \right)
        \\
 \rho c_p \frac{\partial T}{\partial t}  = \nabla \cdot \kappa \nabla T + \vec{J} \cdot \vec{E} + (E_g + 3k_b
        T) \cdot (U - G)
\end{align}
\end{subequations}
This model can be used as power transistor simulation as well as breakdown simulation. Unfortunately, nearly
      all the physical parameters are related with temperature. They should be considered during self consistent
      simulation, which greatly slows down the speed. The $\mathbf{DDML2}$
solver runs $50-70\Percent$ slower than $\mathbf{DDML1}$. However, it seems no convergence
      degradation happens in most of the case. The discretization scheme can be found at [[TODO]].
\par
\section{Level 3 Energy Balance Equation}
\label{sec:Equation:EBML3}
\index{EBML3!Equation}Energy Balance Model \cite[PISCES-2ET]{}
is introduced into GENIUS code for simulating
      short channel MOSFET. This is a simplification of full hydrodynamic (HD) model
\cite[Aste2003]{}. The
      current density expressions from the drift-diffusion model are modified to include additional coupling to the
      carrier temperature. Also, reduced carrier energy conservation equations, which derived from second order moment
      of Boltzmann Transport Equation, are solved consistently with drift-diffusion model. The simplification from HD to
      EB makes sophisticated Scharfetter-Gummel discretization still can be used in the numerical solution, which
      ensures the stability.
\par
\marginhead{Current Equation for EBM}\index{Drift-diffusion current!EBML3}The current density
$\vec{J}_n$ and $\vec{J}_p$ are then expressed as:
\par
\par
\begin{subequations}
\begin{align}
 \vec{J}_n  = q\mu_n n \vec{E}_n + k_b \mu_n \left( {n\nabla T_n + T_n \nabla n} \right)  \\
 \vec{J}_p  = q\mu_p p \vec{E}_p - k_b \mu_p \left( {p\nabla T_p + T_p \nabla p} \right)
\end{align}
\end{subequations}
where, $T\_n$ and $T\_p$ are electron and hole temperature, respectively. The difference between above
      equations and carrier density equations in $\mathbf{DDML2}$
is lattice temperature replaced by carrier
      temperature.
\par
\marginhead{Energy Balance Equations}\index{Energy-balance equation!EBML3}In addition, the energy balance model includes the following electron and hole energy balance
        equations:
\par
\par
\begin{subequations}
\begin{align}
 \frac{\partial \left( {n\omega _n } \right)} {\partial t} + \nabla \cdot \vec{S}_n  = \vec{E}_n \cdot
        \vec{J}_n +H_n \\
 \frac{\partial \left( {p\omega _p } \right)} {\partial t} + \nabla \cdot \vec{S}_p = \vec{E}_p \cdot
        \vec{J}_p +H_p
\end{align}
\end{subequations}
where, $\omega _n$ and $\omega _p$ are electron and
      hole energy. For HD model, the carrier energy includes thermal and kinetic terms
$\omega _c =
      \frac{3}{2}k_bT_c + \frac{1}{2}m^* v_c^2$, but only thermal energy for EB model
$\omega _c = \frac{3}{2}k_bT_c$. Here $c$ stands for $n$ or $p$.
$\omega_0=\frac{3}{2}k_bT$ is the carrier equilibrium energy, for carrier temperature equals to lattice temperature.
\par
$\vec{S}_n$ and $\vec{S}_p$ are the flux of
      energy:
\par
\begin{subequations}
\begin{align}
 \vec{S}_n  = - \kappa _n \nabla T_n - \left( \omega_n + k_b T_n \right) \frac{\vec{J}_n} {q}  \\
 \vec{S}_p  = - \kappa _p \nabla T_p + \left( \omega_p + k_b T_p \right) \frac{\vec{J}_p} {q}
\end{align}
\end{subequations}
The heat conductivity parameter for carriers can be expressed as:
\par
\begin{equation}
\kappa_c=(\frac{2}{5}+\gamma)\frac{{k_b}^2}{q}T_c\mu_cc
\end{equation}
where $c$ stands for $n$ and $p$, respectively. The constant parameter
$\gamma$ equals $-0.7$ in the GENIUS software.
\par
The $H_n$ and $H_p$ are the rate of net loss of
      carrier kinetic energy:
\par
\begin{subequations}
\begin{align}
 H_n =  \left( R_{\rm Aug} - G \right) \cdot \left( E_g + \frac{3k_b T_p } {2} \right) -
        \frac{3k_b T_n } {2}\left( R_{\rm SHR} + R_{\rm dir} - G \right) \\
  -\frac{{n\left( {\omega _n - \omega _0 } \right)}}{{\tau _n }} \\
 H_p =  \left( R_{\rm Aug} - G \right) \cdot \left( E_g + \frac{3k_b T_n } {2} \right) -
        \frac{3k_b T_p}{2}\left( R_{\rm SHR} + R_{\rm dir} - G \right) \\
  - \frac{p\left( \omega _p - \omega _0 \right)}{\tau _p }
\end{align}
\end{subequations}
\marginhead{Lattice Heat Equation for EBM}\index{Heat flow equation!EBML3}At last, the lattice heat flow equation should be rewritten as:
\par
\par
\begin{equation}
\rho c_p \frac{\partial T}{\partial t} = \nabla \cdot \kappa \nabla T + H
\end{equation}
where
\par
\begin{equation}
H = R_{\rm SHR} \cdot \left( E_g + \frac{3k_b T_p } {2} + \frac{3k_b T_n } {2} \right) + \frac{
        n\left( \omega _n - \omega _0 \right)} {\tau _n } + \frac{p\left( \omega _p - \omega _0 \right)}{\tau _p
        }
\end{equation}
The carrier energy is mainly contributed by joule heating term $\vec{E}_c\cdot
      \vec{J}_c$, and heating (cooling) due to carrier generation (recombination) term. The carriers exchange
      energy with lattice by collision, which described by energy relaxation term
$\tau_{\omega
      _c}$. This model is suitable for sub-micron MOS (channel length
$1\sim 0.1
      \uMeter$) and advanced BJT simulation. However, the computation burden of EB method is much higher than
      DD. And the convergence of EB solver is difficult to achieve, which requires more strict initial value and more
      powerful inner linear solver. The discretization scheme can be found at [[TODO]].
\par
From above discussion, all the governing equations of DD/EB method is elliptical or parabolic. From
      mathematic point of view, does not like hyperbolic system\footnote{One have to face discontinuous problem, i.e. shock wave.}, the solution of elliptical or parabolic system is always smooth. The required numerical technique
      is simple and mature for these systems. As a result, the DD and EB method is preferred against full hydrodynamic
      method.
\par
\section{Band Structure Model}
The band structure parameters, including bandgap $E_g$, effective density of
      states in the conduction band $N_c$ and valence band $N_v$, and intrinsic carrier concentration
$n_{ie}$, are the most
      important and fundamental physical parameters for semiconductor material
\cite[Sze1981]{}.
\par
\marginhead{Effective Density of States}Effective density of states\index{Density of states!effective}
in the conduction and valence band are defined as follows:
\par
\par
\begin{subequations}
\begin{align}
 N_{c}  \equiv 2\left( \frac{{m_{n}}^{*}k_{b}T}{2\pi\hbar^2}\right)^{3/2}\\
 N_{v}  \equiv 2\left( \frac{{m_{p}}^{*}k_{b}T}{2\pi\hbar^2}\right)^{3/2}
\end{align}
\end{subequations}
The temperature dependencies of effective density of states is fairly simple:
\par
\begin{subequations}
\begin{align}
 N_{c}\left(T\right) = N_c \left( 300\Kelvin \right)\left( \frac{T}{300\Kelvin}\right)^{1.5}\\
 N_{v}\left(T\right)  = N_v \left( 300\Kelvin \right)\left( \frac{T}{300\Kelvin}\right)^{1.5}
\end{align}
\end{subequations}
\marginhead{Bandgap}The bandgap in GENIUS is expressed as follows:
\par
\par
\begin{subequations}
\begin{align}
 E_g (T) = E_g (0) - \frac{\alpha T^{\rm 2} }{T + \beta} \\
  =E_g (300) + \alpha\left[ \frac{300^{\rm 2} }{300 + \beta} - \frac{T^2}{T + \beta} \right]
\end{align}
\end{subequations}
\marginhead{Bandgap Narrowing due to Heavy Doping}When bandgap narrowing effects\index{Bandgap narrowing!Slotboom model}
due to heavy doping takes place \cite[Slotboom1977]{}, the band edge shifts:
\par
\par
\begin{equation}
\Delta E_g = \frac{E_{\rm bgn}}{2k_b T}\left[ \ln \frac{N_{\rm total}}{N_{\rm ref}} + \sqrt {\left(
        \ln \frac{N_{\rm total}}{N_{\rm ref}} \right)^2 + C_{\rm bgn}} \right].
\end{equation}
The intrinsic concentration should be modified:
\par
\begin{equation}
n_{ie}=\sqrt{N_c N_v } \exp\left(-\frac{E_g}{2 k_b T} \right) \cdot \exp(\Delta E_g)
\end{equation}
Since the carrier current \eqref{eq:Equation:DDML1:DrivingField},
p. \pageref{eq:Equation:DDML1:DrivingField} involves the energy level of
      conduction band $N_{c}$ and valence band $N_{v}$, the
      bandgap shift should be attributed to them. The bandgap narrowing is attributed half to the conduction band and
      another half to the valence band as default:
\par
\begin{subequations}
\begin{align}
 E_c'  =E_c-\frac{1}{2}\Delta E_g \\
 E_v'  =E_v+\frac{1}{2}\Delta E_g
\end{align}
\end{subequations}
The parameters used in the default band structure model is listed in
\tabref{tab:Equation:Band:Default:Param}, p. \pageref{tab:Equation:Band:Default:Param}.
\par
\begin{longtable}{lllll}
\caption{\label{tab:Equation:Band:Default:Param}Parameters of the Default band structure model}
\\
\hline
 Symbol
& Parameter
& Unit
& Silicon
& GaAs\\
\hline
$E_g(300)$
& $\mathbf{EG300}$
& $\eVolt$
& 1.1241
& 1.424
\\
 $\alpha$
& $\mathbf{EGALPH}$
& $\eVolt\Per\Kelvin$
& $2.73\times10^{-4}$
& $5.405\times10^{-4}$
\\
 $\beta$
& $\mathbf{EGBETA}$
& $\Kelvin$
& $0$
& $204$
\\
 $E_{\rm bgn}$
& $\mathbf{V0.BGN}$
& $\eVolt$
& $6.92\times10^{-3}$
& 0
\\
 $N_{\rm ref}$
& $\mathbf{N0.BGN}$
& $cm^3$
& $1.30\times10^{17}$
& $1\times10^{17}$
\\
 $C_{\rm bgn}$
& $\mathbf{CON.BGN}$
& -
& $0.5$
& $0.5$
\\
 $m_n$
& $\mathbf{ELECMASS}$
& $m_0$
& $1.0903$
& $0.067$
\\
 $m_p$
& $\mathbf{HOLEMASS}$
& $m_0$
& $1.1525$
& $0.6415$
\\
 $N_c(300)$
& $\mathbf{NC300}$
& $cm^3$
& $2.86\times10^{19}$
& $4.7\times10^{17}$
\\
 $N_v(300)$
& $\mathbf{NV300}$
& $cm^3$
& $3.10\times10^{19}$
& $7.0\times10^{18}$\\
\end{longtable}

\subsection{Band structure of compound semiconductors}
[[TODO]]
\par
\subsubsection{Band Structure of SiGe}
[[TODO]]
\par
\subsubsection{Band Structure of Tertiary Compound Semiconductor}
[[TODO]]
\par
\marginhead{Bandgap}[[TODO]]
\par
\par
\marginhead{Electron Affinity}[[TODO]]
\par
\par
\marginhead{Effective Mass}[[TODO]]
\par
\par
\marginhead{Density of States}[[TODO]]
\par
\par
\subsection{Schenk's Bandgap Narrowing Model}
[[TODO]] Equations of Schenk's model
\par
The Schenk's bandgap narrowing model is available for silicon, and can be loaded with the option
$\mathbf{Schenk}$ in the $\mathbf{PMI}$ command.
\par
\section{Carrier Recombination}
Three recombination mechanisms are considered in GENIUS at present, including Shockley-Read-Hall, Auger, and
      direct (or radiative) recombination. The total recombination is considered as the sum of all:
\par
\begin{equation}
U = U_n = U_p = U_{\rm SRH} + U_{\rm dir} + U_{\rm Auger}
\end{equation}
where $U_{\rm SRH}$, $U_{\rm dir}$ and $U_{\rm Auger}$ are SRH recombination, direct recombination and Auger recombination,
      respectively.
\par
\marginhead{SRH Recombination}Shockley-Read-Hall (SRH) recombination\index{SRH recombination} see index ''Shockley-Read-Hall recombination''
rate is determined by the following formula:
\par
\par
\begin{equation}
U_{\rm SRH}=\dfrac{pn-{n_{ie}}^2}{\tau_p\left[n+n_{ie}\exp\left(\dfrac{\bf
        ETRAP}{kT_L}\right)\right]+\tau_n\left[p+n_{ie}\exp\left(\dfrac{ -{\bf ETRAP}}{kT_L}\right)\right]}
\end{equation}
where $\tau_n$ and $\tau_p$ are carrier life
      time\index{Carrier life-time}, which dependent on impurity concentration
\cite[Roulston1982]{}.
\par
\begin{subequations}
\begin{align}
 \tau_n  =\frac{{\bf TAUN0}}{1+N_{\rm total}/ {\bf NSRHN}} \\
 \tau_p  =\frac{{\bf TAUP0}}{1+N_{\rm total}/ {\bf NSRHP}}
\end{align}
\end{subequations}
\marginhead{Auger Recombination}The Auger recombination\index{Auger recombination}
is a three-carrier recombination process, involving either two electrons and one hole or two
        holes and one electron. This mechanism becomes important when carrier concentration is large.
\par
\par
\begin{equation}
U_{\rm Auger}={\bf AUGN} \left(pn^2-n{n_{ie}}^2 \right)+{\bf AUGP}(np^2-p{{n_{ie}}^2})
\end{equation}
where $\mathbf{AUGN}$ and $\mathbf{AUGP}$ are Auger coefficient for electrons and
      holes. The value of Auger recombination $U_{\rm Auger}$ can be negative some times,
      which refers to Auger generation.
\par
\marginhead{Direct Recombination}The direct recombination\index{Direct recombination}
model expresses the recombination rate as a function of the carrier concentrations
$n$ and $p$, and the effective intrinsic density $n_{ie}$:
\par
\par
\begin{equation}
U_{\rm dir}={\bf DIRECT}(np-{n_{ie}}^2)
\end{equation}
The default value of the recombination parameters are listed in
\tabref{tab:Equation:Recomb:Param}, p. \pageref{tab:Equation:Recomb:Param}:
\par
\begin{longtable}{lllll}
\caption{\label{tab:Equation:Recomb:Param}Default values of recombination parameters} \\
\hline
 Parameter
& Unit
& Silicon
& GaAs
& Ge\\
\hline
$\mathbf{ETRAP}$
& $\eVolt$
& 0
& 0
& 0
\\
 $\mathbf{DIRECT}$
& $cm^3s^{-1}$
& 1.1e-14
& 7.2e-10
& 6.41e-14
\\
 $\mathbf{AUGN}$
& $cm^6s^{-1}$
& 1.1e-30
& 1e-30
& 1e-30
\\
 $\mathbf{AUGP}$
& $cm^6s^{-1}$
& 0.3e-30
& 1e-29
& 1e-30
\\
 $\mathbf{TAUN0}$
& $\Second$
& 1e-7
& 5e-9
& 1e-7
\\
 $\mathbf{TAUP0}$
& $\Second$
& 1e-7
& 3e-6
& 1e-7
\\
 $\mathbf{NSRHN}$
& $cm^3$
& 5e16
& 5e17
& 5e16
\\
 $\mathbf{NSRHP}$
& $cm^3$
& 5e16
& 5e17
& 5e16\\
\end{longtable}
\marginhead{Surface Recombination}At semiconductor-insulator interfaces, additional SRH recombination can be introduced. The surface
        recombination rate has the unit $cm^{-2}s{-1}$, and is calculated
        with
\par
\par
\begin{equation}
U_{\rm Surf}=\dfrac{pn-{n_{ie}}^2}{\dfrac{1}{\bf STAUN}\left(n+n_{ie}\right)+\dfrac{1}{\bf
        STAUP}\left(p+n_{ie}\right)}.
\end{equation}
The surface recombination velocities, $\mathbf{STAUN}$ and $\mathbf{STAUP}$, have
      the unit of \cMeter\Per\Second, and the default value of 0.
\par
\section{Mobility Models}
\label{sec:Equation:Mobility}
Carrier mobility is one of the most important parameters in the carrier transport model. The DD model
      itself, developed at early 1980s, is still being used today due to advanced mobility model enlarged its ability to
      sub-micron device.
\par
Mobility modeling is normally divided into: low field behavior, high field behavior and mobility in the
      (MOS) inversion layer.
\par
The low electric field behavior has carriers almost in equilibrium with the lattice. The low-field mobility
      is commonly denoted by the symbol $\mu_{n0}$, $\mu_{p0}$.
      The value of this mobility is dependent upon phonon and impurity scattering. Both of which act to decrease the low
      field mobility. Since scattering mechanism is depended on lattice temperature, the low-field mobility is also a
      function of lattice temperature.
\par
The high electric field behavior shows that the carrier mobility declines with electric field because the
      carriers that gain energy can take part in a wider range of scattering processes. The mean drift velocity no
      longer increases linearly with increasing electric field, but rises more slowly. Eventually, the velocity doesn't
      increase any more with increasing field but saturates at a constant velocity. This constant velocity is commonly
      denoted by the symbol $v_{sat}$. Impurity scattering is relatively insignificant for
      energetic carriers, and so $v_{sat}$ is primarily a function of the lattice
      temperature.
\par
Modeling carrier mobilities in inversion layers introduces additional complications. Carriers in inversion
      layers are subject to surface scattering, carrier-carrier scattering, velocity overshoot and quantum mechanical
      size quantization effects. These effects must be accounted for in order to perform accurate simulation of MOS
      devices. The transverse electric field is often used as a parameter that indicates the strength of inversion layer
      phenomena.
\par
It can be seen that some physical mechanisms such as velocity overshoot and quantum effect which can't be
      described by DD method at all, can be taken into account by comprehensive mobility model. The comprehensive
      mobility model extends the application range of DD method. However, when the EB method (which accounts for
      velocity overshoot) and QDD method (including quantum effect) are used, more calibrations are needed to existing
      mobility models.
\par
\subsection{Bulk Mobility Models}
The first family of mobility models were designed to model the carrier transport at low electric fields.
        They usually focus on the temperature and doping concentration dependence of the carrier mobilities. The
        surface-related or transverse E-field effects are \emph{not}
included in these models. On the
        other hand, in GENIUS, these low-field mobilities models are coupled to a velocity saturation model to account
        for the carrier velocity saturation effect. This family of mobility models are suitable for bulk device, such as
        bipolar transistors.
\par
In brief, the low field carrier mobility is first computed, then a velocity saturation formula is applied
        to yield the corrected mobility value. Three choices are available for the low-field mobility calculation, each
        described in one of the following sub-sections. The choices of velocity saturation is described in the last
        sub-section.
\par
\subsubsection{Analytic Mobility Model}
\label{sec:Equation:Mobility:Bulk:Analytic}
\index{mobility!Analytic model}In the GENIUS code, the Analytic Mobility model
\cite[Selberherr1984P]{} is the
          default low field mobility model for all the material. It is an concentration and temperature dependent
          empirical mobility model expressed as:
\par
\begin{equation}
\mu_{0}=\mu_{\rm min}+\dfrac{\mu_{\rm max}\left(\dfrac{T}{300}\right)^\nu-\mu_{\rm
            min}}{1+\left(\dfrac{T}{300}\right)^\xi \left(\dfrac{N_{\rm total}}{N_{\rm ref}}\right)^\alpha}
\end{equation}
where $N_{\rm total}=N_A+N_D$ is the total impurity concentration.
\par
Default parameters for Si, GaAs and Ge are listed below:
\par
\begin{longtable}{lllllll}
\caption{\label{tab:Equation:Mobility:Analytic:Param}Default parameter values of the analytic mobility model} \\
\hline
 Symbol
& Parameter
& Unit
& Si:n
& Si:p
& GaAs:n
& GaAs:p\\
\hline
 $\mu_{\rm min}$
& $\mathbf{MUN.MIN}$ / $\mathbf{MUP.MIN}$
& $cm^2V^{-1}s^{-1}$
& 55.24
& 49.70
& 0.0
& 0.0
\\
 $\mu_{\rm max}$
& $\mathbf{MUN.MAX}$ / $\mathbf{MUP.MAX}$
& $cm^2V^{-1}s^{-1}$
& 1429.23
& 479.37
& 8500.0
& 400.0
\\
 $\nu$
& $\mathbf{NUN}$ / $\mathbf{NUP}$
& -
& -2.3
& -2.2
& -1.0
& -2.1
\\
 $\xi$
& $\mathbf{XIN}$ / $\mathbf{XIP}$
& -
& -3.8
& -3.7
& 0.0
& 0.0
\\
 $\alpha$
& $\mathbf{ALPHAN}$ / $\mathbf{ALPHAP}$
& -
& 0.73
& 0.70
& 0.436
& 0.395
\\
 $N_{\rm ref}$
& $\mathbf{NREFN}$ / $\mathbf{NREFP}$
& $cm^{-3}$
& 1.072e17
& 1.606e17
& 1.69e17
& 2.75e17\\
\end{longtable}
In GENIUS, the analytic model is the simplest mobility model, and is available for a wide range of
          materials. For some materials, such as silicon, some more advanced mobility models are available.
\par
\par
\subsubsection{Masetti Analytic Model}
\label{sec:Equation:Mobility:Bulk:Masetti}
\index{mobility!Masetii model}The doping-dependent low-field mobility model proposed by Masetti et
          al.\cite[Masetti1983]{} is an alternative to the default analytic model. The general expression
          for the low-field mobility is
\par
\begin{equation}
\mu_{\rm dop} = \mu_{\rm min1} \exp\left( -\frac{P_c} {N_{\rm tot}} \right) + \frac{\mu_{\rm
            const} - \mu_{\rm min2}}{1+\left( N_{\rm tot}/C_r \right)^\alpha } - \frac{\mu_1}{1 + \left( C_s/N_{\rm tot}
            \right)^\beta }
\end{equation}
where $N_{\rm tot}$ is the total doping concentration. The term
$\mu_{\rm const}$ is the temperature-dependent, phonon-limited mobility
\par
\begin{equation}
\mu_{\rm const} = \mu_{\rm max} \left( \frac{T}{300} \right)^{\zeta}
\end{equation}
where $T$ is the lattice temperature.
\par
The parameters of the Masetti model is listed in \tabref{tab:Equation:Mobility:Masetti:Param},
p. \pageref{tab:Equation:Mobility:Masetti:Param}.
          The Masetti model is the default mobility model for the 4H-SiC material.
\par
\begin{longtable}{lllll}
\caption{\label{tab:Equation:Mobility:Masetti:Param}Parameters of the Masetti mobility model} \\
\hline
 Symbol
& Parameter
& Unit
& 4H-SiC:n
& 4H-SiC:p\\
\hline
$\mu_{\rm max}$
& $\mathbf{MUN.MAX}$ / $\mathbf{MUP.MAX}$
& $cm^2V^{-1}s^{-1}$
& 947.0
& 124.0
\\
 $\zeta$
& $\mathbf{MUN.ZETA}$ / $\mathbf{MUP.ZETA}$
& -
& 1.962
& 1.424
\\
 $\mu_{\rm min1}$
& $\mathbf{MUN.MIN1}$ / $\mathbf{MUP.MIN1}$
& $cm^2V^{-1}s^{-1}$
& 0
& 15.9
\\
 $\mu_{\rm min2}$
& $\mathbf{MUN.MIN2}$ / $\mathbf{MUP.MIN2}$
& $cm^2V^{-1}s^{-1}$
& 0
& 15.9
\\
 $\mu_1$
& $\mathbf{MUN1}$ / $\mathbf{MUP1}$
& $cm^2V^{-1}s^{-1}$
& 0
& 0
\\
 $P_c$
& $\mathbf{PCN}$ / $\mathbf{PCP}$
& $cm^{-3}$
& 0
& 0
\\
 $C_r$
& $\mathbf{CRN}$ / $\mathbf{CRP}$
& $cm^{-3}$
& $1.94\times 10^{17}$
& $1.76\times 10^{19}$
\\
 $C_s$
& $\mathbf{CSN}$ / $\mathbf{CSP}$
& $cm^{-3}$
& 0
& 0
\\
 $\alpha$
& $\mathbf{MUN.ALPHA}$ / $\mathbf{MUP.ALPHA}$
& -
& 0.61
& 0.34
\\
 $\beta$
& $\mathbf{MUN.BETA}$ / $\mathbf{MUP.BETA}$
& -
& 0
& 0\\
\end{longtable}

\par
\subsubsection{Philips Mobility Model}
\label{sec:Equation:Mobility:Bulk:Philips}
\index{mobility!Philips model}Another low field mobility model implemented into GENIUS is the Philips Unified Mobility model
\cite[Klaassen1992-1]{},\cite[Klaassen1992-2]{}. This model takes into account the
          distinct acceptor and donor scattering, carrier-carrier scattering and carrier screening, which is recommended
          for bipolar devices simulation.
\par
The electron mobility is described by the following expressions:
\par
\begin{equation}
{\mu_{0,n}}^{-1} = {\mu_{{\rm Lattice},n}}^{-1} + {\mu _{D + A + p}}^{-1}
\end{equation}
where $\mu_{0,n}$ is the total low field electron mobilities, $\mu_{{\rm Lattice},n}$
is the electron mobilities due to lattice scattering, $\mu_{D + A + p}$
is the electron and hole mobilities due to donor (D), acceptor (A),
          screening (P) and carrier-carrier scattering.
\par
\begin{equation}
\mu_{{\rm Lattice},n}=\mu_{\rm max} \left( \frac{T}{300} \right)^{-2.285}
\end{equation}
\begin{equation}
\mu _{D + A + p} = \mu_{1,n} \left( \frac{N_{{\rm sc,}n}}{N_{{\rm sc,eff,}n}} \right) \left(
            \frac{N_{\rm ref}}{N_{{\rm sc,}n} } \right)^\alpha + \mu_{2,n} \left( \frac{n + p}{N_{{\rm sc,eff,}n}}
            \right)
\end{equation}
The parameters $\mu_{1,n}$ and $\mu_{2,n}$ are
          given as:
\par
\begin{subequations}
\begin{align}
 \mu_{1,n}  = \frac{ \mu_{\rm max }^2 }{ \mu_{\rm max } - \mu_{\rm min } }
            \left(\frac{T}{300} \right)^{3\alpha - 1.5} \\
 \mu_{2,n}  = \frac{ \mu_{\rm max } \cdot \mu_{\rm min } }{ \mu_{\rm max } - \mu_{\rm min}
            } \left( \frac{300}{T} \right)^{1.5}
\end{align}
\end{subequations}
where ${N_{{\rm sc,}n} }$ and ${N_{{\rm
          sc,eff,}n}}$ is the impurity-carrier scattering concentration and effect impurity-carrier scattering
          concentration given by:
\par
\begin{subequations}
\begin{align}
N_{{\rm sc,}n} = {N_D}^* + N_A^* + p \\
N_{{\rm sc,eff,}n} = {N_D}^* + {N_A}^* G\left( {P_n } \right) + \frac{p}{ F\left( {P_n } \right)
            }
\end{align}
\end{subequations}
where $N_D^*$ and $N_A^*$ take ultra-high doping
          effects into account and are defined by:
\par
\begin{subequations}
\begin{align}
 {N_D}^* = N_D \left( 1 + \dfrac{1}{C_D + \left( \dfrac{N_{D,{\rm ref}}}{N_D} \right)^2 }
            \right) \\
 {N_A}^* = N_A \left( 1 + \dfrac{1}{C_A + \left( \dfrac{N_{A,{\rm ref}}}{N_A } \right)^2 }
            \right)
\end{align}
\end{subequations}
The screening factor functions $G\left( P_n \right)$ and $F\left( P_n \right)$
take the repulsive potential for acceptors and the finite mass of
          scattering holes into account.
\par
\begin{equation}
G\left( P_n \right) = 1 - \frac{0.89233}{\left[ 0.41372 + P_n \left(
            \frac{m_0}{m_e}\frac{T}{300} \right)^{0.28227} \right]^{0.19778} } + \frac{0.005978}{\left[ P_n \left(
            \frac{m_e}{m_0}\frac{T}{300} \right)^{0.72169} \right]^{1.80618}}
\end{equation}
\begin{equation}
F\left( P_n \right) = \frac{0.7643{P_n}^{0.6478} + 2.2999 + 6.5502\frac{m_e}{m_h} }
            {{P_n}^{0.6478} + 2.3670 - 0.8552\frac{m_e}{m_h} }
\end{equation}
The $P_n$ parameter that takes screening effects into account is given
          by:
\par
\begin{equation}
P_n = \left[ {\frac{ f_{cw} }{ N_{\rm sc,ref} \cdot {N_{{\rm sc,}n}}^{-2/3} } + \dfrac{ f_{BH}
            }{ \dfrac{ N_{\rm c,ref} } {n + p}\left( \dfrac{m_e}{m_0} \right)}} \right]^{-1} \left( \frac{T}{300}
            \right)^2
\end{equation}
Similar expressions hold for holes. The default parameters for Philips model are listed in
\tabref{tab:Equation:Mobility:Philips:Param}, p. \pageref{tab:Equation:Mobility:Philips:Param}:
\par
\begin{longtable}{lllll}
\caption{\label{tab:Equation:Mobility:Philips:Param}Default values of Philips mobility model parameters} \\
\hline
 Symbol
& Parameter
& Unit
& Si:n
& Si:p\\
\hline
 $\mu_{\rm min}$
& $\mathbf{MMNN.UM}$ / $\mathbf{MMNP.UM}$
& $cm^2V^{-1}s^{-1}$
& 55.24
& 49.70
\\
 $\mu_{\rm max}$
& $\mathbf{MMXN.UM}$ / $\mathbf{MMXP.UM}$
& $cm^2V^{-1}s^{-1}$
& 1417.0
& 470.5
\\
 $\alpha$
& $\mathbf{ALPN.UM}$ / $\mathbf{ALPP.UM}$
& -
& 0.68
& 0.719
\\
 $N_{\rm ref}$
& $\mathbf{NRFN.UM}$ / $\mathbf{NRFP.UM}$
& $cm^{-3}$
& 9.68e16
& 2.23e17
\\
 $C_D$
& $\mathbf{CRFD.UM}$
& -
& 0.21
& 0.21
\\
 $C_A$
& $\mathbf{CRFA.UM}$
& -
& 0.5
& 0.5
\\
 $N_{\rm D,ref}$
& $\mathbf{NRFD.UM}$
& $cm^{-3}$
& 4.0e20
& 4.0e20
\\
 $N_{\rm A,ref}$
& $\mathbf{NRFA.UM}$
& $cm^{-3}$
& 7.2e20
& 7.2e20
\\
 $m_e$
& $\mathbf{me_over_m0}$
& $m_0$
& 1.0
& -
\\
 $m_h$
& $\mathbf{mh_over_m0}$
& $m_0$
& -
& 1.258
\\
 $f_{cw}$
&
& -
& 2.459
& 2.459
\\
 $f_{BH}$
&
& -
& 3.828
& 3.828
\\
 $N_{\rm sc, ref}$
& $\mathbf{NSC.REF}$
& $cm^{-2}$
& 3.97e13
& 3.97e13
\\
 $N_{\rm c,ref}$
& $\mathbf{CAR.REF}$
& $cm^{-3}$
& 1.36e20
& 1.36e20\\
\end{longtable}
In the actual code, Philips model is corrected by Caughey-Thomas expression for taking high field
          velocity saturation effects into account. This model can be loaded by
$\mathbf{Philips}$ keyword
          in the $\mathbf{PMI}$ statements.
\par
\subsubsection{Velocity Saturation}
\label{sec:Equation:Mobility:Bulk:VSat}
\index{velocity saturation}
\par
\marginhead{Silicon-like materials}\index{velocity saturation!Caughey-Thomas model}For silicon-like materials, the Caughey-Thomas expression
\cite[Caughey1967]{}, is
            used:
\par
\par
\begin{equation}
\mu = \dfrac{\mu _{0} }{\left[ 1 + \left( \dfrac{\mu _{0} E_{\parallel} }{v_{\rm sat} }
            \right)^\beta \right]^{1/\beta} }
\end{equation}
where $E_{\parallel}$ is the electric field parallel to current flow.
$v_{\rm sat}$ is the saturation velocities for electrons or holes. They are
          computed by default from the expression:
\par
\begin{equation}
v_{\rm sat} (T) = \frac{ v_{\rm sat0} }{ 1 + \alpha \cdot \exp \left( \frac{T}{600} \right)
            }
\end{equation}
The parameters and the default values for silicon is listed in \tabref{tab:Equation:Vsat:Si:Param},
p. \pageref{tab:Equation:Vsat:Si:Param}.
\par
\begin{longtable}{lllll}
\caption{\label{tab:Equation:Vsat:Si:Param}Velocity saturation parameters of silicon-like materials} \\
\hline
 Symbol
& Parameter
& Unit
& Si:n
& Si:p\\
\hline
$v_{\rm sat0}$
& $\mathbf{VSATN0}$ / $\mathbf{VSATP0}$
& $\cMeter\Per\Second$
& $2.4\times10^7$
& $2.4\times10^7$
\\
 $\beta$
& $\mathbf{BETAN}$ / $\mathbf{BETAP}$
& -
& 2.0
& 1.0
\\
 $\alpha$
& $\mathbf{VSATN.A}$ / $\mathbf{VSATP.A}$
& -
& 0.8
& 0.8\\
\end{longtable}
\marginhead{GaAs-like materials}\index{velocity saturation!GaAs-like}For GaAs-like materials, another expression due to
\cite[Barnes1976]{} is used to
            describe the negative differential resistance:
\par
\par
\begin{equation}
u = \frac{ \mu _{0} + \dfrac{ v_{sat} }{ E_{\parallel} } \left( \dfrac{E_{\parallel} }{ E_{0} }
            \right)^4 } {1 + \left( \dfrac{E_{\parallel} }{ E_{0} } \right)^4 }
\end{equation}
where $E_{0}$ is the reference field, and the saturation velocity
\par
\begin{equation}
v_{sat} (T) = A_{\rm vsat} - B_{\rm vsat} T
\end{equation}
The negative differential property of carrier mobility is described in this model. When electric field
          increases in this model, the carrier drift velocity ($\mu E_{\parallel}$) reaches
          a peak and then begins to decrease at high fields due to the transferred electron effect.
\par
The parameters are listed in \tabref{tab:Equation:Vsat:GaAs:Param},
p. \pageref{tab:Equation:Vsat:GaAs:Param}.
\par
\begin{longtable}{lllll}
\caption{\label{tab:Equation:Vsat:GaAs:Param}Velocity saturation parameters of GaAs-like materials} \\
\hline
 Symbol
& Parameter
& Unit
& GaAs:n
& GaAs:p\\
\hline
 $A_{\rm vsat}$
& $\mathbf{VSATN.A}$ / $\mathbf{VSATP.B}$
& $\cMeter\Per\Second$
& $1.13\times10^{7}$
& $1.13\times10^{7}$
\\
 $B_{\rm vsat}$
& $\mathbf{VSATN.A}$ / $\mathbf{VSATP.B}$
& $\cMeter\Per\Second\Per\Kelvin$
& $1.2\times10^{4}$
& $1.2\times10^{4}$\\
\end{longtable}

\par
\marginhead{GaAs-specific model}\index{velocity saturation!hyper-tangent model}When using this model for GaAs MESFET device simulation, the negative differential property
            may cause the drain output characteristics (current vs. voltage) exhibit an unrealistic oscillation
            behavior. Another model to describe high field effects developed by Yeager
\cite[Yeager1986]{} can be used.
\par
\par
\begin{equation}
\mu = \frac{v_{\rm sat} }{ E_{\parallel}} \tanh \left( \frac{\mu _0 E_{\parallel} } {v_{\rm sat}
            } \right)
\end{equation}
This GaAs-specific model can be loaded by $\mathbf{Hypertang}$ keyword in
$\mathbf{PMI}$ statement.
\par
\marginhead{4H-SiC-specific model}For 4H-SiC, the saturation velocity is calculated with the following formula
\par
\par
\begin{equation}
v_{sat} (T) = A_{\rm vsat} - B_{\rm vsat} \left( \frac{T}{300} \right)
\end{equation}
where the parameters are listed in
\par
\begin{longtable}{llllll}
\caption{\label{tab:Equation:Vsat:4HSiC:Param}Velocity saturation parameters of 4H-SiC} \\
\hline
 Symbol
& Parameter
& Unit
& 4H-SiC:n
& 4H-SiC:p\\
\hline
 $A_{\rm vsat}$
& $\mathbf{VSATN.A}$ / $\mathbf{VSATP.B}$
& $\cMeter\Per\Second$
& $1.07\times10^{7}$
& $8.37\times10^{6}$
\\
 $B_{\rm vsat}$
& $\mathbf{VSATN.A}$ / $\mathbf{VSATP.B}$
& $\cMeter\Per\Second$
& $0$
& $0$\\
\end{longtable}

\subsection{Unified Mobility Models}
The other family of mobility models are the unified mobility models. The effect of high transverse and
        parallel E-field is an integral part in the design of these mobility models. As a result, these models are
        recommended for silicon MOSFET simulation. On the other hand, the availability of the unified models is limited
        to a few materials, such as silicon and silicon-germanium.
\par
\subsubsection{Lombardi Surface Mobility Model}
\label{sec:Equation:Mobility:Unified:Lombardi}
\index{mobility!Lombardi model}Along an insulator-semiconductor interface, the carrier mobilities can be substantially lower
          than in the bulk of the semiconductor due to surface-related scattering. If no surface degradation is
          considered, the drain-source current may exceed about
$30\Percent$ for MOS
          simulation.
\par
The Lombardi mobility model \cite[Lombardi1988]{} is an empirical model that is able to
          describe the carrier mobility in the MOSFET inversion layer. The Lombardi model consists of three
          components
\par
\begin{compactitem}
\item $\mu_b$, the doping-dependent bulk mobility. This component mainly
                accounts for the ionized impurity scattering.
\par
\item $\mu_{\rm ac}$, the mobility degradation due to acoustic phonon
                scattering in the inversion layer. Due to the quantum confinement in the potential well at the
                interface, this mobility degradation is a strong function of the transverse electric field.
\par
\item $\mu_{\rm sr}$, the mobility degradation due to the surface roughness
                scattering. This component is also a strong function of the transverse electric field.
\par
\end{compactitem}
To obtain the final value of carrier mobility, the three components are combined using the
          Matthiessen's rule:
\par
\begin{equation}
{\mu_{\rm s}}^{ - 1} = {\mu_b}^{-1} + {\mu _{\rm ac}}^{ - 1} + {\mu _{\rm
            sr}}^{-1}.
\end{equation}
\marginhead{Bulk Component}The bulk mobility component in Lombardi's model is similar to that of Masetti's model, which
            reads
\par
\par
\begin{equation}
\mu_b = \mu_0 \exp\left( -\frac{P_c} {N_{\rm tot}} \right) + \frac{\mu_{\rm max} -
            \mu_0}{1+\left( N_{\rm tot}/C_r \right)^\alpha } - \frac{\mu_1}{1 + \left( C_s/N_{\rm tot} \right)^\beta
            }
\end{equation}
\begin{equation}
\mu_{\rm max} = \mu_2 \left( \frac{T}{300} \right)^\zeta
\end{equation}
\marginhead{Acoustic Phonon Component}The acoustic phonon limited mobility component is
\par
\par
\begin{equation}
\mu_{\rm ac} = \frac{B}{E_\bot} + \dfrac{C \cdot {N_{\rm total}}^{\lambda} }{ T \sqrt[3]{E_\bot}
            }
\end{equation}
where $E_\bot$ is the transverse component of the electric field.
\par
\marginhead{Surface Roughness Component}Finally, the surface roughness limited mobility is expressed as
\par
\par
\begin{equation}
\label{eq:Equation:Mobility:Lombardi:SR}
\mu_{\rm sr} = \frac{D}{E_{\bot}^{\gamma} }.
\end{equation}
The Lombardi model is uses the Caughey-Thomas model for velocity saturation calculation, see
\nameref{sec:Equation:Mobility:Bulk:VSat}, p. \pageref{sec:Equation:Mobility:Bulk:VSat}
for details.
\par
The parameters used in the Lombardi model is summarized in \tabref{tab:Equation:Mobility:Lombardi:Param},
p. \pageref{tab:Equation:Mobility:Lombardi:Param}.
\par
\begin{longtable}{llllll}
\caption{\label{tab:Equation:Mobility:Lombardi:Param}Parameters of Lombardi mobility model} \\
\hline
 Symbol
& Parameter
& Unit
& Si:n
& Si:p\\
\hline
 $\alpha$
& $\mathbf{EXN1.LSM}$ / $\mathbf{EXP1.LSM}$
& -
& 0.680
& 0.719
\\
 $\beta$
& $\mathbf{EXN2.LSM}$ / $\mathbf{EXP2.LSM}$
& -
& 2.0
& 2.0
\\
 $\zeta$
& $\mathbf{EXN3.LSM}$ / $\mathbf{EXP3.LSM}$
& -
& 2.5
& 2.2
\\
 $\lambda$
& $\mathbf{EXN4.LSM}$ / $\mathbf{EXP4.LSM}$
& -
& 0.125
& 0.0317
\\
 $\gamma$
& $\mathbf{EXN8.LSM}$ / $\mathbf{EXP8.LSM}$
& -
& 2.0
& 2.0
\\
 $\mu_0$
& $\mathbf{MUN0.LSM}$ / $\mathbf{MUP0.LSM}$
& $cm^2V^{-1}s^{-1}$
& $52.2$
& $44.9$
\\
 $\mu_1$
& $\mathbf{MUN1.LSM}$ / $\mathbf{MUP1.LSM}$
& $cm^2V^{-1}s^{-1}$
& $43.4$
& $29.0$
\\
 $\mu_2$
& $\mathbf{MUN2.LSM}$ / $\mathbf{MUP2.LSM}$
& $cm^2V^{-1}s^{-1}$
& $1417.0$
& $470.5$
\\
 $P_c$
& $\mathbf{PC.LSM}$
& $cm^{-3}$
& 0 (fixed)
& $9.23\times 10^{16}$
\\
 $C_r$
& $\mathbf{CRN.LSM}$ / $\mathbf{CRP.LSM}$
& $cm^{-3}$
& $9.68\times 10^{16}$
& $2.23\times 10^{17}$
\\
 $C_s$
& $\mathbf{CSN.LSM}$ / $\mathbf{CSP.LSM}$
& $cm^{-3}$
& $3.43\times 10^{20}$
& $6.10\times 10^{20}$
\\
 $B$
& $\mathbf{BN.LSM}$ / $\mathbf{BP.LSM}$
& $\cMeter\Per\Second$
& $4.75\times 10^{7}$
& $9.93\times 10^{6}$
\\
 $C$
& $\mathbf{CN.LSM}$ / $\mathbf{CP.LSM}$
& -
& $1.74\times 10^{5}$
& $8.84\times 10^{5}$
\\
 $D$
& $\mathbf{DN.LSM}$ / $\mathbf{DP.LSM}$
& -
& $5.82\times 10^{14}$
& $2.05\times 10^{14}$
\\
 $v_{\rm sat0}$
& $\mathbf{VSATN0}$ / $\mathbf{VSATP0}$
& $\cMeter\Per\Second$
& $2.4\times 10^7$
& $2.4\times 10^7$
\\
 $\beta$
& $\mathbf{BETAN}$ / $\mathbf{BETAP}$
& -
& 2.0
& 1.0
\\
 $\alpha$
& $\mathbf{VSATN.A}$ / $\mathbf{VSATP.A}$
& -
& 0.8
& 0.8\\
\end{longtable}
Hewlett-Packard mobility model can be loaded by $\mathbf{Lombardi}$
keyword in the $\mathbf{PMI}$ statement.
\par
\subsubsection{Lucent High Field Mobility Model}
\label{sec:Equation:Mobility:Unified:Lucent}
\index{mobility!Lucent model}The Lucent Mobility model \cite[Darwish1997]{}
is an all-inclusive model which
          suitable for MOS simulation. This model incorporates Philips Unified Mobility model and the Lombardi Surface
          Mobility model, as well as accounting for high field effects. For low longitudinal field, the carrier mobility
          is given by Matthiessen's rule:
\par
\begin{equation}
\mu_{0} = \left[ \frac{1}{\mu_{\rm b}} + \frac{1}{\mu_{\rm ac} } + \frac{1}{\mu_{\rm sr} }
            \right]^{-1}
\end{equation}
where $\mu_b$ is the bulk mobility comes from the Philips model, and
$\mu_{\rm ac}$ and $\mu_{\rm sr}$ come from the Lombardi
          model. The details of these models are described in \nameref{sec:Equation:Mobility:Bulk:Philips},
p. \pageref{sec:Equation:Mobility:Bulk:Philips} and \nameref{sec:Equation:Mobility:Unified:Lombardi},
p. \pageref{sec:Equation:Mobility:Unified:Lombardi}, and will not be repeated here.
\par
There is however a modification to the surface roughness formula
\eqref{eq:Equation:Mobility:Lombardi:SR}, p. \pageref{eq:Equation:Mobility:Lombardi:SR}. The constant exponent
$\lambda$ is
          replaced by the following function
\par
\begin{equation}
\lambda = A + \dfrac{ F\cdot (n+p) } { N_{\rm tot} ^ \nu }.
\end{equation}
The Lucent model uses the Caughey-Thomas model for velocity saturation calculation, see
\nameref{sec:Equation:Mobility:Bulk:VSat}, p. \pageref{sec:Equation:Mobility:Bulk:VSat}
for details.
\par
The parameters of the Lucent model is listed in \tabref{tab:Equation:Mobility:Lucent:Param},
p. \pageref{tab:Equation:Mobility:Lucent:Param}.
\par
\begin{widetext}
aaaa Default values of Lucent mobility modelDefault values of Lucent mobility modelDefault values of Lucent mobility modelDefault values of Lucent mobility modelDefault values of Lucent mobility modelDefault values of Lucent mobility modelDefault values of Lucent mobility modelDefault values of Lucent mobility modelDefault values of Lucent mobility model
\end{widetext}
\begin{longtable}{lllll}
\caption{\label{tab:Equation:Mobility:Lucent:Param}Default values of Lucent mobility model parameters} \\
\hline
 Symbol
& Parameter
& Unit
& Si:n
& Si:p\\
\hline
 $\mu_{\rm min}$
& $\mathbf{MMNN.UM}$ / $\mathbf{MMNP.UM}$
& $cm^2V^{-1}s^{-1}$
& 55.24
& 49.70
\\
 $\mu_{\rm max}$
& $\mathbf{MMXN.UM}$ / $\mathbf{MMXP.UM}$
& $cm^2V^{-1}s^{-1}$
& 1417.0
& 470.5
\\
 $\alpha$
& $\mathbf{ALPN.UM}$ / $\mathbf{ALPP.UM}$
& -
& 0.68
& 0.719
\\
 $N_{\rm ref}$
& $\mathbf{NRFN.UM}$ / $\mathbf{NRFP.UM}$
& $cm^{-3}$
& 9.68e16
& 2.23e17
\\
 $C_D$
& $\mathbf{CRFD.UM}$
& -
& 0.21
& 0.21
\\
 $C_A$
& $\mathbf{CRFA.UM}$
& -
& 0.5
& 0.5
\\
 $N_{\rm D,ref}$
& $\mathbf{NRFD.UM}$
& $cm^{-3}$
& 4.0e20
& 4.0e20
\\
 $N_{\rm A,ref}$
& $\mathbf{NRFA.UM}$
& $cm^{-3}$
& 7.2e20
& 7.2e20
\\
 $m_e$
& $\mathbf{me_over_m0}$
& $m_0$
& 1.0
& -
\\
 $m_h$
& $\mathbf{mh_over_m0}$
& $m_0$
& -
& 1.258
\\
 $f_{cw}$
&
& -
& 2.459
& 2.459
\\
 $f_{BH}$
&
& -
& 3.828
& 3.828
\\
 $N_{\rm sc, ref}$
& $\mathbf{NSC.REF}$
& $cm^{-2}$
& 3.97e13
& 3.97e13
\\
 $N_{\rm c,ref}$
& $\mathbf{CAR.REF}$
& $cm^{-3}$
& 1.36e20
& 1.36e20
\\
 $v_{\rm sat0}$
& $\mathbf{VSATN0}$ / $\mathbf{VSATP0}$
& $\cMeter\Per\Second$
& $2.4\times10^7$
& 2.47
\\
 $\lambda$
& $\mathbf{EXN4.LUC}$ / $\mathbf{EXP4.LUC}$
& -
& 0.0233
& 0.0119
\\
 $\nu$
& $\mathbf{EXN9.LUC}$ / $\mathbf{EXP9.LUC}$
& -
& 0.0767
& 0.123
\\
 $A$
& $\mathbf{AN.LUC}$ / $\mathbf{AP.LUC}$
& -
& $2.58$
& $2.18$
\\
 $B$
& $\mathbf{BN.LUC}$ / $\mathbf{BP.LUC}$
& $\cMeter\Per\Second$
& $3.61\times 10^{7}$
& $1.51\times 10^{7}$
\\
 $C$
& $\mathbf{CN.LUC}$ / $\mathbf{CP.LUC}$
& -
& $1.70\times 10^{4}$
& $4.18\times 10^{3}$
\\
 $D$
& $\mathbf{DN.LUC}$ / $\mathbf{DP.LUC}$
& -
& $3.58\times 10^{18}$
& $3.58\times 10^{18}$
\\
 $F$
& $\mathbf{FN.LUC}$ / $\mathbf{FP.LUC}$
& -
& $6.85\times 10^{-21}$
& $7.82\times 10^{-21}$
\\
 $K$
& $\mathbf{KN.LUC}$ / $\mathbf{KP.LUC}$
& -
& $1.70$
& $0.90$
\\
 $v_{\rm sat0}$
& $\mathbf{VSATN0}$ / $\mathbf{VSATP0}$
& $\cMeter\Per\Second$
& $2.4\times10^7$
& $2.4\times10^7$
\\
 $\beta$
& $\mathbf{BETAN}$ / $\mathbf{BETAP}$
& -
& 2.0
& 1.0
\\
 $\alpha$
& $\mathbf{VSATN.A}$ / $\mathbf{VSATP.A}$
& -
& 0.8
& 0.8\\
\end{longtable}

The Lucent model can be loaded by $\mathbf{Lucent}$ keyword in the
$\mathbf{PMI}$ statements. This is an accurate model recommended for MOS devices. However, its computation cost is higher
          than other mobility models. At the same time, it is also less numerically stable.
\par
\par
\subsubsection{Hewlett-Packard High Field Mobility Model}
\label{sec:Equation:Mobility:Unified:HP}
\index{mobility!HP model}It is reported that Hewlett-Packard mobility model
\cite[Cham1986]{} achieves the
          same accuracy as Lucent model with relatively small computational burden in the MOS simulation.
\par
This model also takes into account dependence on electric fields both parallel ($E_\parallel$) and perpendicular ($E_\bot$) to the direction
          of current flow. The mobility is calculated from
\par
\begin{equation}
\mu = \dfrac{\mu _{\bot} } {\sqrt {1 + \dfrac{ \left( \dfrac{\mu_{\bot} E_{\parallel} }{v_{c} }
            \right)^2 } {\dfrac{\mu_{\bot} E_{\parallel} }{v_{c} } + \gamma } + \dfrac{\mu_{\bot} E_{\parallel} } {v_{s}
            } } }
\end{equation}
where the tranverse field dependent component $\mu_{\bot}$ is given
          as:
\par
\begin{equation}
\mu_{\bot} = \  \mu_{0}   \text{if } N_{\rm total} > N_{\rm ref} \\
             \dfrac{\mu_0}{ 1+\dfrac{E_{\bot}}{E_{\rm ref}} }
\end{equation}
The low field mobility $\mu_{0}$ is calculated from the $\mathbf{Analytic}$
model, as described in \nameref{sec:Equation:Mobility:Bulk:Analytic},
p. \pageref{sec:Equation:Mobility:Bulk:Analytic}.
\par
The parameters of the Hewlett-Packard mobility model and its default values for silicon is listed in
\tabref{tab:Equation:Mobility:HP:Param}, p. \pageref{tab:Equation:Mobility:HP:Param}.
\par
\begin{longtable}{lllll}
\caption{\label{tab:Equation:Mobility:HP:Param}Default values of HP mobility model parameters}\\
\hline
 Symbol
& Parameter
& Unit
& Si:n
& Si:p\\
\hline
 $\mu_{\rm min}$
& $\mathbf{MUN.MIN}$ / $\mathbf{MUP.MIN}$
& $cm^2V^{-1}s^{-1}$
& 55.24
& 49.70
\\
 $\mu_{\rm max}$
& $\mathbf{MUN.MAX}$ / $\mathbf{MUP.MAX}$
& $cm^2V^{-1}s^{-1}$
& 1429.23
& 479.37
\\
 $\nu$
& $\mathbf{NUN}$ / $\mathbf{NUP}$
& -
& -2.3
& -2.2
\\
 $\xi$
& $\mathbf{XIN}$ / $\mathbf{XIP}$
& -
& -3.8
& -3.7
\\
 $\alpha$
& $\mathbf{ALPHAN}$ / $\mathbf{ALPHAP}$
& -
& 0.73
& 0.70
\\
 $N_{\rm ref}$
& $\mathbf{NREFN}$ / $\mathbf{NREFP}$
& $cm^{-3}$
& $1.072\times 10^{17}$
& $1.606\times 10^{17}$
\\
 $\mu_0$
& $\mathbf{MUN0.HP}$ / $\mathbf{MUP0.HP}$
& $cm^2V^{-1}s^{-1}$
& 774.0
& 250
\\
 $v_c$
& $\mathbf{VCN.NP}$ / $\mathbf{VCP.HP}$
& $cm.s^{-1}$
& $4.9\times 10^6$
& $2.928 \times 10^6$
\\
 $v_s$
& $\mathbf{VSN.NP}$ / $\mathbf{VSP.HP}$
& $cm.s^{-1}$
& $1.036\times 10^7$
& $1.2\times 10^7$
\\
 $\gamma$
& $\mathbf{GN.HP}$ / $\mathbf{GP.HP}$
& -
& 8.8
& 1.6
\\
 $N_{\rm ref}$
& $\mathbf{NREFN}$ / $\mathbf{NREFP}$
& $cm^{-3}$
& $5\times 10^{17}$
& $5\times 10^{17}$
\\
 $E_{\rm ref}$
& $\mathbf{ECN.HP}$ / $\mathbf{ECP.HP}$
& $V.cm^{-1}$
& $5.5\times 10^5$
& $2.78\times 10^5$\\
\end{longtable}
The Hewlett-Packard mobility model can be loaded by $\mathbf{HP}$
keyword in the $\mathbf{PMI}$ statement.
\par
\subsection{Mobility Models of Complex Compound Semiconductors}
[[TODO]]
\par
\subsection{Carrier Temperature Based Mobility Model}
We should notice here, all the above mobility models are developed under the framework of DD method. Since
        DD is an approximate model for semiconductor, the difference between DD model and real device is corrected by
        mobility models! These mobility model contains some physical model that DD does not consider. For example, the
        high field correction has already contains the effect of hot carriers. The surface mobility for MOSFET not only
        considers the mobility degrade due to surface roughness, but also contains the effect caused by carrier
        concentration decrease due to quantum well in inverse layer. These corrections extended the application range of
        DD model, also make the mobility model rather complex.
\par
When the physical model is more accurate, the carrier mobility model can be less complicated. Thus, the
        mobility models suitable for DD model may NOT be suitable for energy balance model. There are some mobility
        models developed special for energy balance model \cite[PISCES-2ET]{}. However, they are yet to be
        implemented in GENIUS.
\par
\section{Generation Model}
\subsection{Impact Ionization}
\label{sec:Equation:Generation:II}
\index{Impact ionization}The generation rate of electron-hole pairs due to the carrier impact ionization (II) is generally
        modeled as \cite[Sze1981]{}:
\par
\begin{equation}
G^{II} = \alpha_n \dfrac{\left\vert \vec{J}_n \right\vert }{q} + \alpha_p \dfrac{ \left\vert
          \vec{J}_p \right\vert }{q}
\end{equation}
where $\alpha_n$ and $\alpha_p$ are electron and
        hole ionization coefficients, related with electrical field, material and temperature.
\par
Three models are implemented in Genius to calculate the ionization coefficient.
\par
\subsubsection{Selberherr Model}
\index{Impact ionization!Selberherr model}Selberherr gives an empirical formula
\cite[Selberherr1984]{}, based on the
          expression derived by Chynoweth\cite[Chynoweth1958]{}:
\par
\begin{equation}
\alpha _{n,p} = \alpha _{n,p}^\infty (T)\exp \left[ - \left( \frac{E_{n,p}^{\rm Crit} }{E_{n,p}
            } \right)^{\gamma_{n,p}} \right]
\end{equation}
where $E_{n,p}$ is the magnitude of driving fields. When $\mathbf{EdotJ}$
model is used, $E_{n,p}$ can be given by:
\par
\begin{subequations}
\begin{align}
 E_n = \frac{ \vec{E} \cdot \vec{J}_n } { \left\vert \vec{J}_n \right\vert }\\
 E_p = \frac{ \vec{E} \cdot \vec{J}_p } { \left\vert \vec{J}_p \right\vert }
\end{align}
\end{subequations}
and for $\mathbf{GradQf}$ model:
\par
\begin{subequations}
\begin{align}
 E_n = \left\vert \nabla \phi_{F_n} \right\vert \\
 E_p = \left\vert \nabla \phi_{F_p} \right\vert
\end{align}
\end{subequations}
where $E_{n,p}^{\rm Crit}=\dfrac{E_g}{q\lambda_{n,p}}$, for which
$\lambda_{n,p}$ are the optical-phonon mean free paths for electrons and holes given
          by:
\par
\begin{subequations}
\begin{align}
 \lambda_n (T) = \lambda_{n,0} \cdot \tanh \left( \dfrac{E_{\rm op}}{2k_b T} \right) \\
 \lambda_p (T) = \lambda_{p,0} \cdot \tanh \left( \dfrac{E_{\rm op}}{2k_b T} \right)
\end{align}
\end{subequations}
in the above expressions, $E_{op}$ is the optical-phonon energy.
$\lambda_{n,0}$ and $\lambda_{p,0}$ are the phonon mean free
          paths for electrons and holes at $300\Kelvin$.
\par
The temperature dependent factors $\alpha_n^\infty$ and $\alpha_p^\infty$
are expressed as:
\par
\begin{subequations}
\begin{align}
 \alpha_n^\infty = \alpha_{n,0} + \alpha_{n,1} \cdot T + \alpha_{n,2} \cdot T^2\\
 \alpha_p^\infty = \alpha_{p,0} + \alpha_{p,1} \cdot T + \alpha_{p,2} \cdot T^2
\end{align}
\end{subequations}
The Selberherr model is the default avalanche model for many materials in Genius. One can also
          explicitly load it with the option $\mathbf{Selberherr}$
in the $\mathbf{PMI}$ statements.The parameters used for Selberherr model are listed in
\tabref{tab:Equation:II:Selberherr:Param}, p. \pageref{tab:Equation:II:Selberherr:Param}.
\par
\begin{longtable}{llllll}
\caption{\label{tab:Equation:II:Selberherr:Param}Default values of Impact Ionization model parameters} \\
\hline
 Symbol
& Parameter
& Unit
& Silicon
& GaAs
& Ge\\
\hline
 $\lambda_{n,0}$
& $\mathbf{LAN300}$
& $\cMeter$
& 1.04542e-6
& 3.52724e-6
& 6.88825e-7
\\
 $\lambda_{p,0}$
& $\mathbf{LAP300}$
& $\cMeter$
& 6.32079e-7
& 3.67649e-6
& 8.39505e-7
\\
 $\gamma_{n}$
& $\mathbf{EXN.II}$
& -
& 1.0
& 1.6
& 1.0
\\
 $\gamma_{p}$
& $\mathbf{EXP.II}$
& -
& 1.0
& 1.75
& 1.0
\\
 $E_{\rm op}$
& $\mathbf{OP.PH.EN}$
& $\eVolt$
& 6.3e-2
& 3.5e-2
& 3.7e-2
\\
 $\alpha_{n,0}$
& $\mathbf{N.IONIZA}$
& $\Inverse\cMeter$
& 7.030e5
& 2.994e5
& 1.55e7
\\
 $\alpha_{n,1}$
& $\mathbf{N.ION.1}$
& $\Inverse\cMeter$
& 0.0
& 0.0
& 0.0
\\
 $\alpha_{n,2}$
& $\mathbf{N.ION.2}$
& $\Inverse\cMeter$
& 0.0
& 0.0
& 0.0
\\
 $\alpha_{p,0}$
& $\mathbf{P.IONIZA}$
& $\Inverse\cMeter$
& 1.528e6
& 2.215e5
& 1e7
\\
 $\alpha_{p,1}$
& $\mathbf{P.ION.1}$
& $\Inverse\cMeter$
& 0.0
& 0.0
& 0.0
\\
 $\alpha_{p,2}$
& $\mathbf{P.ION.2}$
& $\Inverse\cMeter$
& 0.0
& 0.0
& 0.0\\
\end{longtable}

\par
\subsubsection{van Overstraeten - de Man model}
\index{Impact ionization!van Overstraeten - de Man model}The model also uses the ionization coefficient derived by Chynoweth
\cite[Chynoweth1958]{}
\par
\begin{equation}
\alpha = \gamma a \exp \left( -\frac{ \gamma b }{ E } \right),
\end{equation}
where
\par
\begin{equation}
\gamma = \dfrac{\tanh \left(\dfrac{\hbar\omega_{\rm op} }{2kT_0} \right) } { \tanh \left(
            \dfrac{\hbar\omega_{\rm op}}{2kT} \right) }.
\end{equation}
The van Overstraeten - de Man model uses two sets of values for parameter
$a$ and $b$ at high and low electric field. The threshold for
          the switch is $E_0$.
\par
The parameters are listed in \tabref{tab:Equation:II:Overstraeten:Param},
p. \pageref{tab:Equation:II:Overstraeten:Param}.
\par
The van Overstraeten - de Man model is can be selected with the
$\mathbf{vanOverstraetendeMan}$ option in the $\mathbf{PMI}$ command. It is the default
          model for 4H-SiC, InN, InAs and InSb materials.
\par
\begin{longtable}{lllll}
\caption{\label{tab:Equation:II:Overstraeten:Param}van Overstraeten - de Man Impact Ionization model parameters}\\
\hline
 Parameter
& Parameter
& Unit
& 4H-SiC:n
& 4H-SiC:p\\
\hline
 $b$
& $\mathbf{AN.II.LO}$ / $\mathbf{AP.II.LO}$
& $\Inverse\cMeter$
& $4.2\times10^5$
& $4.2\times10^5$
\\
 $b$
& $\mathbf{AN.II.HI}$ / $\mathbf{AP.II.HI}$
& $\Inverse\cMeter$
& $4.2\times10^5$
& $4.2\times10^5$
\\
 $b$
& $\mathbf{BN.II.LO}$ / $\mathbf{BP.II.LO}$
& $V/cm$
& $1.67\times10^7$
& $1.67\times10^7$
\\
 $b$
& $\mathbf{BN.II.HI}$ / $\mathbf{BP.II.HI}$
& $V/cm$
& $1.67\times10^7$
& $1.67\times10^7$
\\
 $E_0$
& $\mathbf{E0N.II}$ / $\mathbf{EOP.II}$
& $V/cm$
& $4\times10^5$
& $4\times10^5$
\\
 $\hbar\omega_{\rm op}$
& $\mathbf{EN.OP.PH}$ / $\mathbf{EP.OP.PH}$
& $\eVolt$
& 1.0
& 1.0\\
\end{longtable}

\subsubsection{Valdinoci Model}
\index{Impact ionization!Valdinoci model}GENIUS has another Valdinoci model for silicon device which has been reported to produce correct
          temperature dependence of breakdown voltage of junction diodes as high as
$400^{\circ}C$ \cite[Valdinoci1999]{}. It can be loaded with the
$\mathbf{Valdinoci}$ option in the $\mathbf{PMI}$ statements.
\par
The electron impact ionization rate for Valdinoci model reads:
\par
\begin{equation}
\alpha _n = \frac{E_{\parallel} } { a_n (T) + b_n (T) \exp \left( \dfrac{d_n(T)}{ E_{\parallel}
            + c_n(T)} \right) }
\end{equation}
where
\par
\begin{subequations}
\begin{align}
 a_n(T) = {\bf A0N} + {\bf A1N} \cdot T^{\bf A2N} \\
 b_n(T) = {\bf B0N} \cdot \exp \left( {\bf B1N} \cdot T \right) \\
 c_n (T) = {\bf C0N} + {\bf C1N} \cdot T^{\bf C2N} + {\bf C3N} \cdot T^2 \\
 d_n (T) = {\bf D0N} + {\bf D1N} \cdot T + {\bf D2N} \cdot T^2
\end{align}
\end{subequations}
Similar expressions hold for holes. The parameters for Valdinoci model are listed in
\tabref{tab:Equation:II:Valdinoci:Param}, p. \pageref{tab:Equation:II:Valdinoci:Param}.
\par
\begin{longtable}{lllll}
\caption{\label{tab:Equation:II:Valdinoci:Param}Default values of Valdinoci Impact Ionization model parameters} \\
\hline
 Parameter
& Silicon:n
& Parameter
& Silicon:p
& Unit\\
\hline
$\mathbf{A0N}$
& 4.3383
& $\mathbf{A0P}$
& 2.376
& $V$
\\
 $\mathbf{A1N}$
& $-2.42\times10^{-12}$
& $\mathbf{A1P}$
& 0.01033
& $V \times K^{A2X}$
\\
 $\mathbf{A2N}$
& 4.1233
& $\mathbf{A2P}$
& 1.0
& -
\\
 $\mathbf{B0N}$
& 0.235
& $\mathbf{B0P}$
& 0.17714
& $\Volt$
\\
 $\mathbf{B1N}$
& 0.0
& $\mathbf{B1P}$
& $-2.178\times10^{-3}$
& $\Inverse\Kelvin$
\\
 $\mathbf{C0N}$
& $1.6831\times10^4$
& $\mathbf{C0P}$
& 0.0
& $V.cm^{-1}$
\\
 $\mathbf{C1N}$
& 4.3796
& $\mathbf{C1P}$
& $9.47\times10^{-3}$
& $V.cm^{-1}\Kelvin^{-{\bf C2X}}$
\\
 $\mathbf{C2N}$
& 1.0
& $\mathbf{C2P}$
& 2.4924
& -
\\
 $\mathbf{C3N}$
& 0.13005
& $\mathbf{C3P}$
& 0.0
& $V.cm^{-1}\ISquare\Kelvin$
\\
 $\mathbf{D0N}$
& $1.233735\times10^6$
& $\mathbf{D0P}$
& $1.4043\times10^6$
& $V.cm^{-1}$
\\
 $\mathbf{D1N}$
& $1.2039\times10^3$
& $\mathbf{D1P}$
& $2.9744\times10^3$
& $V.cm^{-1}\Inverse\Kelvin$
\\
 $\mathbf{D2N}$
& 0.56703
& $\mathbf{D2P}$
& 1.4829
& $V.cm^{-1}\ISquare\Kelvin$\\
\end{longtable}

\par
\subsection{Band-to-band Tunneling}
\index{Band-to-band tunneling!Kane's model}
\par
\marginhead{Kane's model}The carrier generation by band-band tunneling
$G^{BB}$ is also considered by
          Genius, which can be expressed as \cite[Kane1959]{}\cite[Liou1990]{}:
\par
\par
\begin{equation}
G^{BB} = {\rm A.BTBT} \cdot \frac{E^2}{ \sqrt {E_g} } \cdot \exp \left( -{\rm B.BTBT} \cdot
          \dfrac{ {E_g}^{3/2} }{E} \right)
\end{equation}
where $E$ is the magnitude of electrical field.
\par
\section{High Energy Particles}
As a heavy ion passes through the device, it will interact with some silicon atoms and transfer energy to
      the semiconductor lattice, which generates electron-hole pairs along it trajectory. The simulation of high-energy
      particle and the energy deposition in semiconductor can be simulated with the Geant4 or other Monte Carlo
      simulation tool. On the other hand, the generation of electron-hole pairs and the effects to the device behavior
      must be simulated in a 3D device simulator.
\par
Assuming the proton hit the diode at $t=0\Second$, and the electron-hole
      generation rate follows a Gaussian time dependence, with a maximum at
$t_{\rm max}$,
      and a characteristic time $\tau$, the carrier generation rate can be calculated
      by
\par
\begin{equation}
G = G_0 \exp \left[ -\frac{(t-t_{\rm max})^2}{2\tau^2} \right] .
\end{equation}
On the other hand, the Monte Carlo simulators such as Geant4 provides the total energy deposition data,
      which relate to $G$ by
\par
\begin{equation}
\label{eq:Particle:E}
E = \eta \int\limits_0^{\infty} G_0 \exp \left[ -\frac{(t-t_{\rm max})^2}{2\tau^2} \right]
        dt.
\end{equation}
where $\eta$ is the average energy loss for each generated electron-hole pair.
      We therefore have the normalization factor
\par
\begin{equation}
\label{eq:Particle:G0}
G_0 = \frac{2E}{\eta \tau \sqrt{\pi}} .
\end{equation}
\section{Fermi-Dirac Statistics}
\index{Fermi-Dirac distribution}In general, the electron and hole concentrations in semiconductors are defined by Fermi-Dirac
      distributions and density of states:
\par
\begin{subequations}
\begin{align}
 n = N_c {\cal F}_{1/2} \left(\eta _n\right) \\
 p = N_v {\cal F}_{1/2} \left(\eta _p\right)
\end{align}
\end{subequations}
The $\eta _n$ and $\eta _p$ are defined as
      follows:
\par
\begin{subequations}
\begin{align}
 \eta_n = \frac{ E_{F_n} - E_c }{k_b T} = {{\cal F}_{1/2}}^{-1} \left(\frac{n}{N_c}\right) \\
 \eta_p = \frac{ E_v - E_{F_p} }{k_b T} = {{\cal F}_{1/2}}^{-1} \left(\frac{p}{N_v}\right)
\end{align}
\end{subequations}
where $E_{F_n}$ and $E_{F_p}$ are the electron and
      hole Fermi energies. The relationship of Fermi energy and Fermi potential is
$E_{F_n}=-q\phi_n$, $E_{F_p}=-q\phi_p$.
\par
\marginhead{Evaluate Inverse Fermi Integral}${{\cal F}_{1/2}}^{-1}$
is the inverse Fermi integral of order one-half. Joyce
        and Dixon gives its approximation analytic expression in the year of 1977
\cite[Joyce1977]{}, which
        can be given by:
\par
\par
\begin{equation}
{{\cal F}_{1/2}}^{-1} (x) =   \log(x) + ax + bx^2 + cx^3 + dx^4 x < 8.463
         \left[ \left( {\dfrac{3\sqrt \pi }{4} x} \right)^{3/4} - \dfrac{\pi^2}{6} \right]^{1/2}
        \text{otherwise} \\
\end{equation}
\begin{subequations}
\begin{align}
 a = 0.35355339059327379 \\
 b = 0.0049500897298752622 \\
 c = 1.4838577128872821 \times 10^{-4} \\
 d = 4.4256301190009895 \times 10^{-6}
\end{align}
\end{subequations}
In the GENIUS code, the $\eta _n$ and $\eta _p$ are
      derived from carrier concentration by Joyce-Dixon expression.
\par
For convenience, we introduce floowing two parameters as referred by
\cite[SEDAN1985]{}:
\par
\begin{subequations}
\begin{align}
 \gamma_n = \frac{ {\cal F}_{1/2} \left( \eta_n \right) } { \exp \left( \eta _n \right) }  \\
 \gamma_p = \frac{ {\cal F}_{1/2} \left( \eta_p \right) } { \exp \left( \eta _p \right) }
\end{align}
\end{subequations}
The carrier concentration for Fermi statistics and Boltzmann statistics can be described uniformly
      by:
\par
\begin{subequations}
\begin{align}
 n = N_c \gamma_n \exp \left( \eta _n \right) \\
 p = N_v \gamma_p \exp \left( \eta _p \right)
\end{align}
\end{subequations}
where $\gamma_n=\gamma_p=1$ for Boltzmann statistics, and less than
$1.0$ for Fermi statistics.
\par
\marginhead{DD Equation with Fermi Statistics}Consider the drift-diffusion current
\eqref{eq:Equation:DDML1:DDMCurrent}, p. \pageref{eq:Equation:DDML1:DDMCurrent}
when the carrier
        satisfies Fermi statistics and forces zero net current in equilibrium state, one can get the modified current
        equation, for which the Einstein relationship:
\par
\par
\begin{subequations}
\begin{align}
 D_n = \frac{k_b T}{q} \mu_n \\
 D_p = \frac{k_b T}{q} \mu_p
\end{align}
\end{subequations}
should be replaced by:
\par
\begin{subequations}
\begin{align}
 D_n = \frac{k_b T}{q} \mu_n {\cal F}_{1/2} \left( \eta_n \right)/{\cal F}_{-1/2} \left(
        \eta_n \right) \\
 D_p = \frac{k_b T}{q} \mu_p {\cal F}_{1/2} \left( \eta _p \right)/{\cal F}_{-1/2} \left(
        \eta_p \right)
\end{align}
\end{subequations}
where ${\cal F}_{-1/2}$ is the Fermi integral of order minus one-half. The
      corresponding current equation for electrons is
\par
\begin{equation}
\label{eq:Equation:FermiDirac:Jn1}
\vec{J}_n = \mu_n \left( qn \vec{E}_n + k_b T \lambda_n \nabla n \right)
\end{equation}
where
\par
\begin{equation}
\lambda_n = \frac{ {\cal F}_{1/2} \left(\eta _n\right) } { {\cal F}_{-1/2} \left(\eta _n\right)
        }
\end{equation}
The Fermi integral has an useful property:
\par
\begin{equation}
\frac{\partial}{\partial \eta}{\cal F}_\nu (\eta) = {\cal F}_{\nu - 1} (\eta)
\end{equation}
From the above property, one can derive two useful derivatives:
\par
\begin{subequations}
\begin{align}
 \frac{\partial }{\partial n} \eta_n (n) = \frac{\lambda_n}{n} \\
 \frac{\partial }{\partial n} \gamma_n (n) = \frac{ \gamma _n }{n} \left( {1 - \lambda_n } \right)
\end{align}
\end{subequations}
With the two derivatives, \eqref{eq:Equation:FermiDirac:Jn1}, p. \pageref{eq:Equation:FermiDirac:Jn1}
can be rewritten into the following
      equivalent formula:
\par
\begin{equation}
\vec{J}_n = \mu_n \left( qn \vec{E}_n + k_b T\nabla n - n k_b T\nabla \left( \ln \gamma _n \right)
        \right)
\end{equation}
The last term is the modification to Einstein relationship, which can be combinated into potential term. As
      a result, the current \eqref{eq:Equation:DDML1:DDMCurrent},
p. \pageref{eq:Equation:DDML1:DDMCurrent} keeps unchanged, but the effective driving
      force should be modified as:
\par
\begin{equation}
\vec{E}_n = \frac{1}{q}\nabla E_c - \frac{k_b T}{q}\nabla \left( \ln (N_c ) - \ln (T^{3/2} ) \right)
        - \frac{ k_b T}{q}{\nabla \left( \ln \gamma _n \right)}
\end{equation}
The same formula exists for holes:
\par
\begin{equation}
\vec{E}_p = \frac{1}{q}\nabla E_v + \frac{k_b T}{q}\nabla \left( \ln (N_v ) - \ln (T^{3/2} ) \right)
        + \frac{ k_b T}{q}{\nabla \left( \ln \gamma _p \right)}
\end{equation}
As a conclusion, when Fermi statistics is considered, the formula of DD method keeps unchanged, only an
      extra potential term should be considered. However, Fermi statistics also effect the implement of Ohmic boundary
      condition, please refer to [[TODO]]
\par
\chapter{Genius Command Reference}
\section{Introduction}
\subsection{Format of Input Card}
GENIUS code takes its input from a user specified card file. Each line of the card file is a particular
        statement, identified by the first keyword on the card. The remaining parts of the line are the parameters of
        that statement. The statement has the format as follow:
\par
\begin{lstlisting}[style=GeniusCmd]
KEYWORD [parameters]
\end{lstlisting}
The words on a line should be separated by blanks or tabs. If more than one line of input is necessary for
        a particular statement, it may be continued on subsequent lines by placing a backslash sign \textbackslash{} as the last
        non-blank character on the current line.
\par
GENIUS code parses the input file by GNU flex and bison. It first read the
        pattern file located at \$GENIUS\_DIR/lib/genius.key
which provides the keyword names and
        parameter attributes before the parse work. After that, the grammar of user provide file is matched by this
        pattern. With this flexible mechanism, adding new statement to GENIUS is fairly easy.
\par
Parameters may be one of five types: float, integer, bool, string or enumeration. The float point number
        supports C style double precision real number. The integer value also supports C style integer. The bool value
        can be True, On, False and Off. String value is made up of lower line, dot, blank, number and alpha characters.
        The string should not begin with number; quotation marks are only needed when string contains blank. The
        enumerate value is a string with its value in a limited range which is predefined in the pattern file. At last,
        the length of string (including enumerate string) is limited to 80 characters.
\par
All the parameter specification has the same format as
\par
\begin{lstlisting}[style=GeniusCmd]
parameter_name = [number|integer|bool|string|enumeration]
\end{lstlisting}
In the card descriptions, keywords, parameters, enumerate strings are not case sensitive. And their names
        does not need to be typed in full; only enough characters to ensure unique identification is necessary. However
        user input strings is case sensitive, because file name may be specified by the string. Comments must begin with
        '\#' and can be either an separated line or locate at the end of current statement.
\par
\marginhead{The sequence of input deck}Most of the cards GENIUS used are sequence insensitive. The order of occurrence of cards is significant
          in only two cases. The mesh generation cards must have the right order, or it can't work properly. And GENIUS
          will execute the 'driven' cards sequentially. So the placement order of 'driven' cards will affect simulation
          result.
\par
\par
\subsection{Statement Description Format}
\marginhead{Syntax of Parameter Lists}The following special characters are used in the formatted parameter list:
\par
\par
\begin{lstlisting}[style=GeniusCmd]
slanted shape <<num>>   - value of parameter in the indicated type
Square brackets [ ] - optional group
Vertical bar |      - alternate choice
Parentheses ( )     - group hierarchy
Braces { }          - group hierarchy with high level
\end{lstlisting}
\marginhead{Value Types}Besides some string parameters which have fixed values, most of the parameters need a user defined
          value. A lower case letter in angle brackets represents a value of a given type. The following types of values
          are represented:
\par
\par
\begin{lstlisting}[style=GeniusCmd]
<<num>>  - double precision numerical value
<<int>>  - integer value
<<bool>> - boolean value
<<str>>  - string value
<<enum>> - enumeration value
<<a>>-prex - array of values
\end{lstlisting}
\section{Global Specification}
\subsection{GLOBAL}
\index{GLOBAL command}The $\mathbf{GLOBAL}$
command defines some global simulation parameters such as unit scale
        and ambient temperature.
\par
\begin{lstlisting}[style=GeniusCmd]
GLOBAL
  [ TExternal=<<num>> ] [ DopingScale=<<num>> ] [ Orientation=<<int>> ]
  { [ Z.Width=<<num>> ] | [ CylindricalMesh=<<bool>> ] }
  [ ResistiveMetal=<<bool>> ]
\end{lstlisting}
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
\multicolumn{5}{l}{\textbf{Global Simulation Parameters}}
\\
 $\mathbf{TExternal}$
& numerical
& Ambient temperature external to the simulated device. Synonym: LatticeTemp
& 300
& $\Kelvin$
\\
 $\mathbf{DopingScale}$
& numerical
& Doping concentration normalization factor. Physical quantities are normalized based on this
                  factor to reduce numerical errors. Usually, a good choice of this value is the highest doping
                  concentration in the device, although in some cases lower values are more desirable.
& 1e18
& $cm^{-3}$
\\
 $\mathbf{Z.Width}$
& numerical
& For a 2D mesh, the width of the device in the z-direction. Internally calculated current
                  densities are multiplied by this width to produce the terminal currents. This parameter only affect 2D
                  mesh.
& 1.0
& $\uMeter$
\\
 $\mathbf{CylindricalMesh}$
& bool
& For a 2D mesh, Genius will consider it as cylindrically symmetric. Electrical current output is
                  integrated along the angular direction thus in the unit of Amperes.
& false
& none
\\
 $\mathbf{Orientation}$
& integer
& The crystalline orientation of the silicon substrate. Only 100, 110, and 111 are
                  recognized.
& 100
& none
\\
 $\mathbf{ResistiveMetal}$
& bool
& Flag to enable resistive metal in device structure, which is introduced from version
                  1.7.0
& false
& none\\
\end{longtable}

\subsubsection{Description}
When several $\mathbf{GLOBAL}$ commands are present in the input file, and a parameter is set
          multiple times, only the last value takes effect.
\par
\subsubsection{Example}
\begin{lstlisting}[style=GeniusCode]
# device width in Z dimension. Unit:um
GLOBAL Z.Width = 2

# specify initial temperature of device. Unit:K
GLOBAL LatticeTemp = 3e2

# set carrier scale reference value
GLOBAL DopingScale = 1e16

# enable resistive metal
GLOBAL ResistiveMetal = true
\end{lstlisting}
\section{Mesh Generation}
GENIUS code has flexible mesh data structure which support various shapes of 2D and 3D elements. The only
      limit is the element should have circum-circle for 2D or circum-sphere for 3D to meet finite volume method used by
      GENIUS. The supported element shapes can be triangle and quadrangle for 2D, tetrahedron, prism and hexahedron for
      3D. Please note that the triangle and tetrahedron can be any shape; however, quadrangle, prism and hexahedron
      should meet the in circuit or in sphere requirement. The GENIUS solver is designed as element shape independent,
      which means using mixed shapes of elements in mesh is possible.
\par
\begin{figure}[H]
\caption{\label{fig:CmdRef:2dElemnt}2D elements}
%\includegraphics{plotCmdRef/element2d.png}
\end{figure}

\begin{figure}[H]
\caption{\label{fig:CmdRef:3dElemnt}3D elements}
%\includegraphics[scale=120]{plotCmdRef/element3d.png}
\end{figure}

GENIUS offers several build-in mesh generators to build both 2D and 3D mesh for semiconductor device. At
      present, they can only generate simulation mesh with unique mesh element. However, it is possible to import device
      model girded with hyper-mesh from third party mesh generator.
\par
\marginhead{Coordinate System}All the mesh generators use Cartesian coordinate system, in which the top horizontal line has the minimal
        y coordinate, left vertical line has the minimal x coordinate and the front vertical line has the minimal z
        coordinate. In general, y coordinate is the direction vertical to silicon wafer.
\par
\par
\marginhead{Mesh Statements}The device mesh is specified by a series of mesh statements. They are listed as required input
        order:
\par
\par
\begin{compactitem}
\item $\mathbf{MESH}$
\par
\item $\mathbf{X.MESH}$
\par
\item $\mathbf{Y.MESH}$
\par
\item $\mathbf{Z.MESH}$
\par
\item $\mathbf{ELIMATE}$ (optional)
\par
\item $\mathbf{SPREAD}$ or $\mathbf{SPREAD3D}$ (optional)
\par
\item $\mathbf{REGEION}$
\par
\item $\mathbf{FACE}$ (optional)
\par
\end{compactitem}
Please note that the order in which statements appear is important. Changing the order changes the results.
      Generally, a mesh is specified by the following steps:
\par
\begin{compactitem}
\item Tell GENIUS which mesh generator will be used. ($\mathbf{MESH}$)
\par
\item The mesh begins as a set of (nonuniformly) spaced x-, y- and z- lines comprising a simple hexahedron
          ($\mathbf{X.MESH}$, $\mathbf{Y.MESH}$ and $\mathbf{Z.MESH}$).
\par
\item Mesh lines may be terminated inside the device, and redundant nodes removed from the grid
          ($\mathbf{ELIMINATE}$).
\par
\item The hexahedron can be distorted to track non-planar geometry or match the doping profile, although
          strongly non-planar structures are difficult to treat in this way ($\mathbf{SPREAD}$,
$\mathbf{SPREAD3D}$).
\par
\item Material regions can be specified as a union of hexahedrons, completing the mesh specification
          ($\mathbf{REGION}$).
\par
\item Boundary faces can be specified as surface rectangles when necessary ($\mathbf{FACE}$).
\par
\end{compactitem}
\subsection{MESH}
\index{MESH command}This statement indicates the beginning of the mesh generation behavior.
\par
\begin{lstlisting}[style=GeniusCmd]
MESH
  Type=(S_Tet4|S_Prism6|S_Hex8|S_Tri3|S_Quad4)
  [ Triangle=<<str>> ]  [ Tetgen=<<str>> ]
\end{lstlisting}
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
$\mathbf{Type}$
& enum
& Indicates which mesh generator is to be used. It can be one of
$\mathbf{S_Tet4}$, $\mathbf{S_Prism6}$, $\mathbf{S_Hex8}$, $\mathbf{S_Tri3}$
and $\mathbf{S_Quad4}$.
& none
& none
\\
 $\mathbf{Triangle}$
& string
& The parameters passed to triangular mesh generator for $\mathbf{S_Prism6}$
and $\mathbf{S_Tri3}$ meshes. The triangular mesher recognizes the same set of parameters as
                  the Triangle program. The detailed description of the available options can be found at Triangle's
                  home page \url{http://www.cs.cmu.edu/~quake/triangle.html}.
& {\ttsl pzADq30Q}
& none
\\
 $\mathbf{TetGen}$
& string
& The parameters passed to the tetrahedral mesh generator Tetgen code, which is used for
$\mathbf{S_Tet4}$ meshes. The detailed description of this string can be found at Tetgen's
                  home page \url{http://tetgen.berlios.de}
& {\ttsl pzAYq1.5}
& none
\\
 $\mathbf{File.Prefix}$
& string
& File name prefix of the mesh files to be loaded in the simulator. Currently only works with
$\mathbf{S_Tet4}$ meshes generated by Tetgen. For a file prefix {\ttsl
foo}, the files {\ttsl foo.node}, {\ttsl foo.face} and {\ttsl foo.ele}
will be read for node,
                  face, and element data of the mesh, respectively.
& none
& none\\
\end{longtable}

\subsubsection{Description}
All simulations in Genius are performed in a discrete mesh. The available types of meshes are enumerated
          above, and illustrated in \figref{fig:CmdRef:2dElemnt},
p. \pageref{fig:CmdRef:2dElemnt} and \figref{fig:CmdRef:3dElemnt}, p. \pageref{fig:CmdRef:3dElemnt}.
\par
There are two alternative ways to generate the mesh structures. The user can use the
$\mathbf{X.MESH}$, $\mathbf{Y.MESH}$ and $\mathbf{Z.MESH}$ commands to specify the
          position of mesh lines, and have Genius to call the appropriate mesh generator programs behind the
          scene.
\par
Alternatively, the user can define the device geometry with external tools, produce the mesh with an
          external mesh generator, and commands Genius to import from files containing the mesh structure. Currently
          Genius can import mesh files generated by Tetgen for tetrahedral
$\mathbf{S_Tet4}$ meshes.
\par
\subsubsection{Example}
\begin{lstlisting}[style=GeniusCode]
MESH Type=S_Tri3
MESH Type=S_Tet4 Tetgen="pzAq1.5"
MESH Type=S_Tet4 File.Prefix="foo"
\end{lstlisting}
\subsection{X.MESH Y.MESH and Z.MESH}
\index{X.Mesh command}\index{Y.MESH command}\index{Z.MESH command}The
$\mathbf{X.MESH}$, $\mathbf{Y.MESH}$ and $\mathbf{Z.MESH}$ cards
        specify the location of lines of nodes in a hexahedral mesh (rectangular mesh for 2D) . The original mesh can be
        modified by following mesh cards like $\mathbf{ELIMINATE}$
and $\mathbf{SPREAD}$ or $\mathbf{SPREAD3D}$.
\par
\begin{lstlisting}[style=GeniusCmd]
X.MESH
  { Width=<<num>> | ( X.Min=<<num>> X.Max=<<num>> ) }
  { N.Spaces=<<int>> [Ratio=<<num>>] | H1=<<num>> [H2=<<num>>] }
  [Min.Space=<<num>>]

Y.MESH
  { Depth=<<num>> | ( Y.Min=<<num>> Y.Max=<<num>> ) }
  { N.Spaces=<<int>> [Ratio=<<num>>] | H1=<<num>> [H2=<<num>>] }
  [Min.Space=<<num>>]

Z.MESH
  { Width=<<num>> | ( Z.Min=<<num>> Z.Max=<<num>> ) }
  { N.Spaces=<<int>> [Ratio=<<num>>] | H1=<<num>> [H2=<<num>>] }
  [Min.Space=<<num>>]
\end{lstlisting}
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
$\mathbf{Width}$
& numerical
& The distance of the grid section in x or z direction. This direction is parallel to silicon  wafer.
& none
& $\uMeter$
\\
 $\mathbf{Depth}$
& numerical
& The distance of the grid section in y direction. This direction is vertical to silicon
                  wafer.
& none
& $\uMeter$
\\
 $\mathbf{X.Min}$
& numerical
& The x location of the left edge of the grid section. synonym:
$\mathbf{X.Left}$.
                  When more than one $\mathbf{X.Mesh}$ statements exist, the
$\mathbf{X.Min}$ location of next mesh edge will follow most right of previous grid section automatically.
& none
& $\uMeter$
\\
 $\mathbf{X.Max}$
& numerical
& The x location of the right edge of the grid section. synonym:
$\mathbf{X.Right}$.
& none
& $\uMeter$
\\
 $\mathbf{Y.Min}$
& numerical
& The y location of the top edge of the grid section. synonym:
$\mathbf{Y.Top}$. When
                  more than one $\mathbf{Y.Mesh}$ statements exist, the
$\mathbf{Y.Min}$ location of next mesh edge will follow most bottom of previous grid section automatically.
& none
& $\uMeter$
\\
 $\mathbf{Y.Max}$
& numerical
& The y location of the bottom edge of the grid section. synonym:
$\mathbf{Y.Bottom}$.
& none
& $\uMeter$
\\
 $\mathbf{Z.Min}$
& numerical
& The z location of the front edge of the grid section. synonym:
$\mathbf{Z.Front}$.
                  When more than one $\mathbf{Z.Mesh}$ statements exist, the
$\mathbf{Z.Min}$ location of next mesh edge will follow most back of previous grid section automatically.
& none
& $\uMeter$
\\
 $\mathbf{Z.Max}$
& numerical
& The z location of the bottom edge of the grid section. synonym:
$\mathbf{Z.Back}$.
& none
& $\uMeter$
\\
 $\mathbf{N.Spaces}$
& integer
& The number of grid spaces in the grid section.
& 1
& none
\\
 $\mathbf{Ratio}$
& numerical
& The ratio between the sizes of adjacent grid spaces in the grid section.
$\mathbf{Ratio}$ should usually lie between 0.667 and 1.5.
& 1.0
& none
\\
 $\mathbf{H1}$
& numerical
& The size of the grid space at the begin edge of the grid section.
& none
& $\uMeter$
\\
 $\mathbf{H2}$
& numerical
& The size of the grid space at the end edge of the grid section.
& none
& $\uMeter$
\\
 $\mathbf{Min.Space}$
& numerical
& The size of the minimum allowed grid spacing in this grid section.
& 1e-4
& $\uMeter$\\
\end{longtable}

\par
\subsubsection{Description}
[give pictures here]
\par
\subsubsection{Example}
\begin{lstlisting}[style=GeniusCode]
X.MESH    X.MIN=0.0  X.MAX=0.50   N.SPACES=8
Y.MESH    DEPTH=0.1  N.SPACES=8   RATIO=0.8
Y.MESH    DEPTH=0.1  N.SPACES=20
Y.MESH    DEPTH=0.6  H1=0.005  H2=0.050
Z.MESH    WIDTH=1.0  N.SPACES=5
\end{lstlisting}
\subsection{ELIMINATE}
\index{ELIMINATE command}The
$\mathbf{ELIMINATE}$ statement eliminates mesh points along planes in a hexahedral
        grid over a specified volume. This statement is useful for eliminating nodes in regions of the device structure
        where the grid is more dense than necessary. Points along every second line in the chosen direction within the
        chosen range are removed, except the first and last line. Successive eliminations of the same range remove
        points along every fourth line, eighth line, and so on.
\par
\begin{lstlisting}[style=GeniusCmd]
ELIMINATE
  { Direction = (XNorm | YNorm | ZNorm) }
  [ {X.Min=<<num>> | IX.Min=<<int>>} ] [ {X.Max=<<num>> | IX.Max=<<int>>} ]
  [ {Y.Min=<<num>> | IY.Min=<<int>>} ] [ {Y.Max=<<num>> | IY.Max=<<int>>} ]
  [ {Z.Min=<<num>> | IZ.Min=<<int>>} ] [ {Z.Max=<<num>> | IZ.Max=<<int>>} ]
\end{lstlisting}
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
$\mathbf{Direction}$
& enum
& Specifies that lines of nodes in direction of X, Y or Z are eliminated.
& none
& none
\\
 $\mathbf{X.Min}$
& numerical
& The minimum x location of the hexahedron volume in which nodes are eliminated. The default
                  value is the minimum x-coordinates in the device. synonym:
$\mathbf{X.Left}$.
& XMin
& $\uMeter$
\\
 $\mathbf{X.Max}$
& numerical
& The maximum x location of the hexahedron volume in which nodes are eliminated. The default
                  value is the maximum x-coordinates in the device. synonym:
$\mathbf{X.Right}$.
& XMax
& $\uMeter$
\\
 $\mathbf{IX.Min}$
& integer
& The minimum x node index of the hexahedron volume in which nodes are eliminated. synonym:
$\mathbf{IX.Left}$.
& 0
& none
\\
 $\mathbf{IX.Max}$
& integer
& The maximum x node index of the hexahedron volume in which nodes are eliminated. synonym:
$\mathbf{IX.Right}$.
& IXMax-1
& none
\\
 $\mathbf{Y.Min}$
& numerical
& The minimum y location of the hexahedron volume in which nodes are eliminated. The default
                  value is the minimum y-coordinates in the device. synonym:
$\mathbf{Y.Top}$.
& YMin
& $\uMeter$
\\
 $\mathbf{Y.Max}$
& numerical
& The maximum y location of the hexahedron volume in which nodes are eliminated. The default
                  value is the maximum y-coordinates in the device. synonym:
$\mathbf{Y.Bottom}$.
& YMax
& $\uMeter$
\\
 $\mathbf{IY.Min}$
& integer
& The minimum y node index of the hexahedron volume in which nodes are eliminated. synonym:
$\mathbf{IY.Top}$.
& 0
& none
\\
 $\mathbf{IY.Max}$
& integer
& The maximum y node index of the hexahedron volume in which nodes are eliminated. synonym:
$\mathbf{IY.Bottom}$.
& IYMax-1
& none
\\
 $\mathbf{Z.Min}$
& numerical
& The minimum Z location of the hexahedron volume in which nodes are eliminated. The default
                  value is the minimum Z-coordinates in the device. synonym:
$\mathbf{Z.Front}$.
& ZMin
& $\uMeter$
\\
 $\mathbf{Z.Max}$
& numerical
& The maximum z location of the hexahedron volume in which nodes are eliminated. The default
                  value is the maximum z-coordinates in the device. synonym:
$\mathbf{Z.Back}$.
& ZMax
& $\uMeter$
\\
 $\mathbf{IZ.Min}$
& integer
& The minimum z node index of the hexahedron volume in which nodes are eliminated. synonym:
$\mathbf{IZ.Front}$.
& 0
& none
\\
 $\mathbf{IZ.Max}$
& integer
& The maximum x node index of the hexahedron volume in which nodes are eliminated. synonym:
$\mathbf{IZ.Back}$.
& IZMax-1
& none\\
\end{longtable}

\subsubsection{Description}
Not all the mesh generator support $\mathbf{ELIMINATE}$. The $\mathbf{S_QUAD4}$
and $\mathbf{S_HEX8}$ mesh generator can not do mesh line eliminate. User should take care of the
          elimination process. The excessively elimination may cause bad element quality.
\par
\subsubsection{Example}
\begin{lstlisting}[style=GeniusCode]
ELIMINATE    Direction=YNORM    Y.TOP=-1.0
ELIMINATE    Direction=XNORM    IX.MAX=8
\end{lstlisting}
\subsection{SPREAD}
\index{SPREAD command}The $\mathbf{SPREAD}$
statements provide a way to adjust the y position of nodes along
        grid lines parallel to the x-plan (the disturb is uniform in Z dimension) in a hexahedral mesh to follow surface
        and junction contours. The statement is only supported by
$\mathbf{S_Tri3}$, $\mathbf{S_Tet4}$ and $\mathbf{S_Prism6}$ mesh generator.
\par
\begin{lstlisting}[style=GeniusCmd]
SPREAD
  Location = (Left|Right) Width=<<num>> Upper=<<int>> Lower=<<int>>
  [ Enchroach=<<num>>]
  { Y.Lower=<<num>> | (Thickness=<<num>> [Vol.Rat=<<num>>]) }
  [ Grading=<<num>> ]
\end{lstlisting}
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
$\mathbf{Location}$
& enum
& Specifies which side of the grid is distorted.
& none
& none
\\
 $\mathbf{Width}$
& numerical
& The width of the distorted region measured from the left or right edge of the
                  structure.
& 0
& $\uMeter$
\\
 $\mathbf{Upper}$
& integer
& The index of the upper y-grid line of the distorted region.
& 0
& none
\\
 $\mathbf{Lower}$
& integer
& The index of the lower y-grid line of the distorted region.
& 0
& none
\\
 $\mathbf{Encroach}$
& integer
& The factor which defines the abruptness of the transition between distorted and undistorted
                  grid. The transition region becomes more abrupt with smaller
$\mathbf{Encroach}$ factors.
                  The minimum allowed value is 0.1.
& 1.0
& none
\\
 $\mathbf{Y.Lower}$
& numerical
& The vertical location in the distorted region where the line specified by
$\mathbf{Lower}$ is moved. The grid line specified by $\mathbf{Upper}$
does
                  not move if this parameter is specified.
& none
& $\uMeter$
\\
 $\mathbf{Thickness}$
& numerical
& The thickness of the distorted region. Specifying $\mathbf{Thickness}$
usually
                  causes the positions of both the $\mathbf{Upper}$
and $\mathbf{Lower}$ grid
                  lines to move.
& none
& $\uMeter$
\\
 $\mathbf{Vol.Rat}$
& numerical
& The ratio of the displacement of the lower grid line to the net change in thickness. If
$\mathbf{Vol.Rat}$ is 0, the location of the lower grid line does not move. If
$\mathbf{Vol.Rat}$ is 1, the upper grid line does not move.
& 0.44
& none
\\
 $\mathbf{Grading}$
& numerical
& The vertical grid spacing ratio in the distorted region between the y-grid lines specified with
$\mathbf{Upper}$ and $\mathbf{Lower}$. The spacing grows or shrinks by
$\mathbf{Grading}$ in each interval between lines. $\mathbf{Grading}$
should
                  usually lie between 0.667 and 1.5.
& 1.0
& none\\
\end{longtable}

\subsubsection{Example}
\begin{lstlisting}[style=GeniusCode]
SPREAD    Location=Left  Width=0.625 Upper=0 Lower=2 \
          Thickness=0.1

SPREAD    Location=Right Width=0.625 Upper=0 Lower=2 \
          Thickness=0.1
\end{lstlisting}
\par
\subsection{SPREAD3D}
\index{SPREAD3D command}The $\mathbf{SPREAD3D}$
statements also provide a way to adjust the y position of nodes
        along grid lines parallel to the xz-plan in a hexahedral mesh to follow surface and junction contours. The
        statement is only supported by S\_Tet4 mesh generator.
\par
\begin{lstlisting}[style=GeniusCmd]
SPREAD3D
  [ {X.Min=<<num>> | IX.Min=<<int>>} ] [ {X.Max=<<num>> | IX.Max=<<int>>} ]
  [ {Z.Min=<<num>> | IZ.Min=<<int>>} ] [ {Z.Max=<<num>> | IZ.Max=<<int>>} ]
  Upper=<<int>> Lower=<<int>> [ Enchroach=<<num>>]
  { Y.Lower=<<num>>  | (Thickness=<<num>> [Vol.Rat=<<num>>]) }
  [Grading=<<num>>]
\end{lstlisting}
\par
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
$\mathbf{X.Min}$
& numerical
& The minimum x location of the area in which nodes are disturbed. synonym:
$\mathbf{X.Left}$.
& XMIN
& $\uMeter$
\\
 $\mathbf{X.Max}$
& numerical
& The maximum x location of the area in which nodes are disturbed. synonym:
$\mathbf{X.Right}$.
& XMAX
& $\uMeter$
\\
 $\mathbf{IX.Min}$
& integer
& The minimum x node index of the area in which nodes are disturbed. synonym:
$\mathbf{IX.Left}$.
& 0
& none
\\
 $\mathbf{IX.Max}$
& integer
& The maximum x node index of the area in which nodes are disturbed. synonym:
$\mathbf{IX.Right}$.
& IXMAX-1
& none
\\
 $\mathbf{Z.Min}$
& numerical
& The minimum z location of the area in which nodes are disturbed. synonym:
$\mathbf{Z.Front}$.
& ZMIN
& $\uMeter$
\\
 $\mathbf{Z.Max}$
& numerical
& The maximum z location of the area in which nodes are disturbed. synonym:
$\mathbf{Z.Back}$.
& ZMAX
& $\uMeter$
\\
 $\mathbf{IZ.Min}$
& integer
& The minimum z node index of the area in which nodes are disturbed. synonym:
$\mathbf{IZ.Front}$.
& 0
& none
\\
 $\mathbf{IZ.Max}$
& integer
& The maximum z node index of the area in which nodes are disturbed. synonym:
$\mathbf{IZ.Back}$.
& IZMAX-1
& none
\\
 $\mathbf{Upper}$
& integer
& The index of the upper y-grid line of the distorted region.
& 0
& none
\\
 $\mathbf{Lower}$
& integer
& The index of the lower y-grid line of the distorted region.
& 0
& none
\\
 $\mathbf{Encroach}$
& integer
& The factor which defines the abruptness of the transition between distorted and undistorted
                  grid. The transition region becomes more abrupt with smaller
$\mathbf{Encroach}$ factors.
                  The minimum allowed value is 0.1.
& 1.0
& none
\\
 $\mathbf{Y.Lower}$
& numerical
& The vertical location in the distorted region where the line specified by
$\mathbf{Lower}$ is moved. The grid line specified by $\mathbf{Upper}$
does
                  not move if this parameter is specified.
& none
& $\uMeter$
\\
 $\mathbf{Thickness}$
& numerical
& The thickness of the distorted region. Specifying $\mathbf{Thickness}$
usually
                  causes the positions of both the $\mathbf{Upper}$
and $\mathbf{Lower}$ grid
                  lines to move.
& none
& $\uMeter$
\\
 $\mathbf{Vol.Rat}$
& numerical
& The ratio of the displacement of the lower grid line to the net change in thickness. If
$\mathbf{Vol.Rat}$ is 0, the location of the lower grid line does not move. If
$\mathbf{Vol.Rat}$ is 1, the upper grid line does not move.
& 0.44
& none
\\
 $\mathbf{Grading}$
& numerical
& The vertical grid spacing ratio in the distorted region between the y-grid lines specified with
$\mathbf{Upper}$ and $\mathbf{Lower}$. The spacing grows or shrinks by
$\mathbf{Grading}$ in each interval between lines. $\mathbf{Grading}$
should
                  usually lie between 0.667 and 1.5.
& 1.0
& none\\
\end{longtable}

\subsubsection{Example}
\begin{lstlisting}[style=GeniusCode]
SPREAD3D    X.MIN=1.0 X.MAX=2.0 Z.MIN=0.0 Z.MAX=1.0  \
            Upper=0 Lower=2 Thickness=0.1
\end{lstlisting}
\subsection{REGION}
\index{REGION command}The $\mathbf{REGION}$
statement defines the location of materials in the mesh. Currently,
        GENIUS supports following materials: Vacuum; semiconductor material including Si, Ge, GaAs, 3C-SiC,
Si\low{1-x}Ge\low{x}, Al\low{x}Ga\low{1-x}As, In\low{x}Ga\low{1-x}As, InP, InAs, InN, InSb,
Hg\low{(1-x)}Cd\low{(x)}Te; insulator material including Air, SiO\low{2},
Si\low{3}N\low{4} and electrode region including
        Elec, Al, Cu, Au, Ag and PolySi.
\par
\begin{lstlisting}[style=GeniusCmd]
REGION
  Shape=(Rectangle|Ellipse) Label=<<str>> Material=<<str>>
  [ {X.Min=<<num>> | IX.Min=<<int>>} ] [ {X.Max=<<num>> | IX.Max=<<int>>} ]
  [ {Y.Min=<<num>> | IY.Min=<<int>>} ] [ {Y.Max=<<num>> | IY.Max=<<int>>} ]
  [ {Z.Min=<<num>> | IZ.Min=<<int>>} ] [ {Z.Max=<<num>> | IZ.Max=<<int>>} ]
\end{lstlisting}
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
$\mathbf{Shape}$
& enum
& Specifies the shape of the region. Can be $\mathbf{Rectangle}$
or $\mathbf{Ellipse}$.
& $\mathbf{Rectangle}$
& none
\\
 $\mathbf{Label}$
& string
& Specifies the identifier of this region, limited to 12 chars.
& none
& none
\\
 $\mathbf{Material}$
& string
& Specifies the material of the region.
& none
& none
\\
 $\mathbf{X.Min}$
& numerical
& The minimum x location of the region. synonym: $\mathbf{X.Left}$.
& XMIN
& $\uMeter$
\\
 $\mathbf{X.Max}$
& numerical
& The maximum x location of the region. synonym: $\mathbf{X.Right}$.
& XMAX
& $\uMeter$
\\
 $\mathbf{IX.Min}$
& integer
& The minimum x node index of the region. synonym: $\mathbf{IX.Left}$.
& 0
& none
\\
 $\mathbf{IX.Max}$
& integer
& The maximum x node index of the region. synonym: $\mathbf{IX.Right}$.
& IXMAX-1
& none
\\
 $\mathbf{Y.Min}$
& numerical
& The minimum y location of the region. synonym: $\mathbf{Y.Top}$.
& YMIN
& $\uMeter$
\\
 $\mathbf{Y.Max}$
& numerical
& The maximum y location of the region. synonym: $\mathbf{Y.Bottom}$.
& YMAX
& $\uMeter$
\\
 $\mathbf{IY.Min}$
& integer
& The minimum y node index of the region. synonym: $\mathbf{IY.Top}$.
& 0
& none
\\
 $\mathbf{IY.Max}$
& integer
& The maximum y node index of the region. synonym: $\mathbf{IY.Bottom}$.
& IYMAX-1
& none
\\
 $\mathbf{Z.Min}$
& numerical
& The minimum z location of the region. synonym: $\mathbf{Z.Front}$.
& ZMIN
& $\uMeter$
\\
 $\mathbf{Z.Max}$
& numerical
& The maximum z location of the region. synonym: $\mathbf{Z.Back}$.
& ZMAX
& $\uMeter$
\\
 $\mathbf{IZ.Min}$
& integer
& The minimum z node index of the region. synonym: $\mathbf{IZ.Front}$.
& 0
& none
\\
 $\mathbf{IZ.Max}$
& integer
& The maximum z node index of the region. synonym: $\mathbf{IZ.Back}$.
& IZMAX-1
& none\\
\end{longtable}

\par
\subsubsection{Description}
Several regions can be defined one by one. But users should be careful that regions can't get cross each
          other. The situations showed in \figref{fig:CmdRef:Region:MultiRegion},
p. \pageref{fig:CmdRef:Region:MultiRegion}(A) and (B) are allowed, but
          (C) will break the mesh generator of genius.
\par
\begin{figure}[H]
\caption{\label{fig:CmdRef:Region:MultiRegion}Multi-Region definition.}
%\includegraphics[width=0.8\textwidth]{plotCmdRef/region1.png}
\end{figure}

When the background grid line is disturbed by $\mathbf{SPREAD}$ statement, it is something
          difficult for specifying region bounding with grid line location. One can use grid line index instead of grid
          line location here.
\par
\subsubsection{Example}
\begin{lstlisting}[style=GeniusCode]
REGION  Label=Si1   Material=Si   Y.TOP= 0.0 Y.BOTTOM=-0.100
REGION  Label=SiGe1 Material=SiGe Y.TOP=-0.1 Y.BOTTOM=-0.125
\end{lstlisting}
\subsection{FACE}
\index{FACE command}Face is a group of facet elements (triangle and quadrangle for 3D, and edge for 2D) which have the
        same attribute. This statement specifies the label of a special face. User can assign the face with a special
        boundary condition type by $\mathbf{BOUNDARY}$ statement.
\par
\begin{lstlisting}[style=GeniusCmd]
FACE
  Label=<<str>>
  { Location = (Top|Bottom|Left|Right|Front|Back) |
    ( Direction=(XNorm|YNorm|ZNorm) ( X=<<num>>|Y=<<num>>|Z=<<num>> ) ) }
  [ {X.Min=<<num>> | IX.Min=<<int>>} ] [ {X.Max=<<num>> | IX.Max=<<int>>} ]
  [ {Y.Min=<<num>> | IY.Min=<<int>>} ] [ {Y.Max=<<num>> | IY.Max=<<int>>} ]
  [ {Z.Min=<<num>> | IZ.Min=<<int>>} ] [ {Z.Max=<<num>> | IZ.Max=<<int>>} ]
\end{lstlisting}
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
Label
& string
& Specifies the identifier of this face, limited to 80 chars.
& none
& none
\\
 $\mathbf{Location}$
& enum
& Specifies which side the face lies along.
& none
& none
\\
 $\mathbf{Direction}$
& enum
& Specifies the dimensional orientation of the face.
& none
& none
\\
 $\mathbf{X}$
& numerical
& Specifies the X coordinate of the face parallel to YZ plane.
& 0.0
& $\uMeter$
\\
 $\mathbf{Y}$
& numerical
& Specifies the Y coordinate of the face parallel to XZ plane.
& 0.0
& $\uMeter$
\\
 $\mathbf{Z}$
& numerical
& Specifies the Z coordinate of the face parallel to XY plane.
& 0.0
& $\uMeter$
\\
 $\mathbf{X.Min}$
& numerical
& The minimum x location of the face. synonym: $\mathbf{X.Left}$.
& XMIN
& $\uMeter$
\\
 $\mathbf{X.Max}$
& numerical
& The maximum x location of the face. synonym: $\mathbf{X.Right}$.
& XMAX
& $\uMeter$
\\
 $\mathbf{IX.Min}$
& integer
& The minimum x node index of the face. synonym: $\mathbf{IX.Left}$.
& 0
& none
\\
 $\mathbf{IX.Max}$
& integer
& The maximum x node index of the face. synonym: $\mathbf{IX.Right}$.
& IXMAX-1
& none
\\
 $\mathbf{Y.Min}$
& numerical
& The minimum y location of the face. synonym: $\mathbf{Y.Top}$.
& YMIN
& $\uMeter$
\\
 $\mathbf{Y.Max}$
& numerical
& The maximum y location of the face. synonym: $\mathbf{Y.Bottom}$.
& YMAX
& $\uMeter$
\\
 $\mathbf{IY.Min}$
& integer
& The minimum y node index of the face. synonym: $\mathbf{IY.Top}$.
& 0
& none
\\
 $\mathbf{IY.Max}$
& integer
& The maximum y node index of the face. synonym: $\mathbf{IY.Bottom}$.
& IYMAX-1
& none
\\
 $\mathbf{Z.Min}$
& numerical
& The minimum z location of the face. synonym: $\mathbf{Z.Front}$.
& ZMIN
& $\uMeter$
\\
 $\mathbf{Z.Max}$
& numerical
& The maximum z location of the face. synonym: $\mathbf{Z.Back}$.
& ZMAX
& $\uMeter$
\\
 $\mathbf{IZ.Min}$
& integer
& The minimum z node index of the face. synonym: $\mathbf{IZ.Front}$.
& 0
& none
\\
 $\mathbf{IZ.Max}$
& integer
& The maximum z node index of the face. synonym: $\mathbf{IZ.Back}$.
& IZMAX-1
& none\\
\end{longtable}

\subsubsection{Description}
The $\mathbf{FACE}$ statement can specify facet elements not only on the boundary of the mesh,
          but also inside the mesh, i.e. at the interface of two regions. Here gives the rules about how GENIUS dealing
          with of faces. The faces specified by $\mathbf{FACE}$ statement always has the highest priority. They
          will have the label as $\mathbf{FACE}$ statement declared. For the remaining faces, the interface
          faces between two regions will be assigned by {\ttsl name1}\_to\_{\ttsl
name2} in which the {\ttsl name1} and {\ttsl name2} are the labels of the two regions in
          alphabetic order. The remain faces of a region will be assigned by
{\ttsl name}\_Neumann and
          the {\ttsl name} is the label of the region. There are some limitations about
$\mathbf{S_Prism6}$ mesh generator. Face can not be defined along Z direction, i.e. on front or
          back plane.
\par
\subsubsection{Example}
\begin{lstlisting}[style=GeniusCode]
FACE  Label=Anode   Direction=Horizontal X.MIN=0.0 X.MAX=1.0 \
      Z.MIN=0.0 Z.MAX=3.0 Y=0.0

FACE  Label=Cathode Direction=Horizontal X.MIN=0.0 X.MAX=3.0 \
      Z.MIN=0.0 Z.MAX=3.0 Y=3.0

FACE  Label=Anode    Location=TOP   X.MIN=0.0 X.MAX=1.0

FACE  Label=Cathode  Location=BOTTOM
\end{lstlisting}
\subsection{REFINE}
\index{REFINE command}The $\mathbf{REFINE}$
statement allows refinement of a coarse mesh. GENIUS supports three
        types of mesh refinement: uniform, conform and hierarchical mesh refinement. At present, the solution is
        destroyed after the mesh refinement. Thus user should ensure that there are
$\mathbf{DOPING}$ and
        probably $\mathbf{MOLE}$ statements exist in the same input file so that device doping profile and mole
        distribution can be rebuild on the new mesh.
\par
\begin{lstlisting}[style=GeniusCmd]
REFINE.Uniform  [Step=int]

REFINE.Conform
  Variable = ( Doping | Potential | Electron | Hole |
               Temperature | E.Temp | H.Temp | QFN | QFP |
               E.Field | Net.Carrier | Net.Charge |
               Optical.Gen | Particle.Gen )
  Evaluation = ( Gradient | Quantity )
  Measure=( Linear| SignedLog ) [ Region=<<str>> ]
  { error.fraction=<<num>> | cell.fraction=<<num>> |
    error.threshold=<<num>> }

REFINE.Hierarchical
  Variable = ( Doping | Potential | Electron | Hole |
               Temperature | E.Temp | H.Temp | QFN | QFP |
               E.Field | Net.Carrier | Net.Charge )
  Evaluation = ( Gradient | Quantity )
  Measure=( Linear| SignedLog ) [ Region=<<str>> ]
  { error.refine.fraction=<<num>>  | cell.refine.fraction=<<num>>  |
    error.refine.threshold=<<num>> }
  [ error.coarsen.fraction=<<num>> | cell.coarsen.fraction=<<num>> |
    error.coarsen.threshold=<<num>> ]
\end{lstlisting}
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
\multicolumn{5}{l}{\textbf{Uniform Mesh Refine}}
\\
 $\mathbf{Step}$
& integer
& how many steps should the uniform refinement repeats.
& none
& none\\
\multicolumn{5}{l}{\textbf{General Mesh Refinement Parameters}}
\\
 $\mathbf{Variable}$
& enum
& the mesh refinement criteria variable. Can be one of: $\mathbf{Doping}$,
$\mathbf{Potential}$, $\mathbf{Electron}$, $\mathbf{Hole}$, $\mathbf{Temperature}$,
$\mathbf{E.Temp}$, $\mathbf{H.Temp}$, $\mathbf{QFN}$, $\mathbf{QFP}$,
$\mathbf{E.Field}$, $\mathbf{Net.Carrier}$ and $\mathbf{Net.Charge}$.
& none
& none
\\
 $\mathbf{Evaluation}$
& enum
& Specifies whether the variable quantity or its gradient should be used in refinement
                  critiria.
& $\mathbf{Gradient}$
& none
\\
 $\mathbf{Measure}$
& enum
& Specifies that refinement is based on the original value or logarithm of the specified
                  quantity.
& $\mathbf{Linear}$
& none
\\
 $\mathbf{Region}$
& string
& The name of the region over which refinement takes place. Elements in other regions may be
                  refined for mesh conform or well-shaped elements. User can specify several regions by multi Region
                  parameters.
& none
& none\\
\multicolumn{5}{l}{\textbf{Conformal Mesh Refinement}}
\\
 $\mathbf{Error.Fraction}$
& numerical
& When the cell's error exceeds $\mathbf{error.fraction*max_error}$, it will be
                  refined..
& 0.3
& none
\\
 $\mathbf{Error.Threshold}$
& numerical
& When the cell's error exceeds $\mathbf{error.threshold}$, it will be
                  refined.
& 0.1
& none
\\
 $\mathbf{Cell.Fraction}$
& numerical
& The $\mathbf{cell.fraction*(total cell number)}$ of cells with most error will be
                  refined.
& 0.3
& none
\\
 $\mathbf{X.Min}$
& numerical
& The minimum x coordinate of the region that will be considered for refinement. synonym:
$\mathbf{X.Left}$.
& 0
& $\uMeter$
\\
 $\mathbf{X.Max}$
& numerical
& The maximum x coordinate of the region that will be considered for refinement. synonym:
$\mathbf{X.Right}$.
& 0
& $\uMeter$
\\
 $\mathbf{Y.Min}$
& numerical
& The minimum y coordinate of the region that will be considered for refinement. synonym:
$\mathbf{Y.Top}$.
& 0
& $\uMeter$
\\
 $\mathbf{Y.Max}$
& numerical
& The maximum y coordinate of the region that will be considered for refinement. synonym:
$\mathbf{Y.Bottom}$.
& 0
& $\uMeter$
\\
 $\mathbf{Z.Min}$
& numerical
& The minimum z coordinate of the region that will be considered for refinement. synonym:
$\mathbf{Z.Front}$.
& 0
& $\uMeter$
\\
 $\mathbf{Z.Max}$
& numerical
& The maximum z coordinate of the region that will be considered for refinement. synonym:
$\mathbf{Z.Back}$.
& 0
& $\uMeter$\\
\multicolumn{5}{l}{\textbf{Hierarchical Mesh Refinement/Coarsening}}
\\
 $\mathbf{Error.Refine.Fr}$
& numerical
& When the cell's error exceeds $\mathbf{error.refine.fraction*max_error}$, it will
                  be refined. synonym: Error.Refine.Fraction
& 0.3
& none
\\
 $\mathbf{Error.Coarsen.Fr}$
& numerical
& When the cell's error is less than $\mathbf{error.coarsen.fraction*max_error}$, it
                  will be coarsened. synonym: $\mathbf{Error.Coarsen.Fraction}$
& 0.0
& none
\\
 $\mathbf{Error.Refine.Th}$
& numerical
& When the cell's error exceeds $\mathbf{error.refine.threshold}$, it will be
                  refined. synonym: $\mathbf{Error.Refine.Threshold}$
& 0.1
& none
\\
 $\mathbf{Error.Coarsen.Th}$
& numerical
& When the cell's error is less than $\mathbf{error.coarsen.threshold}$, it will be
                  coarsened. synonym: $\mathbf{Error.Coarsen.Threshold}$
& 0.1
& none
\\
 $\mathbf{Cell.Refine.Fr}$
& numerical
& The $\mathbf{cell.refine.fraction*(total cell number)}$ of cells with most error
                  will be refined. synonym: $\mathbf{Cell.Refine.Fraction}$
& 0.3
& none
\\
 $\mathbf{Cell.Coarsen.Fr}$
& numerical
& The $\mathbf{cell.coarsen.fraction*(total cell number)}$ of cells with least error
                  will be coarsened. synonym: $\mathbf{Cell.Coarsen.Fraction}$
& 0.3
& none\\
\end{longtable}

\subsubsection{Description}
$\mathbf{REFINE.Uniform}$ is only intended for debugging. Only $\mathbf{TRI3}$
and $\mathbf{TET4}$ mesh can do $\mathbf{REFINE.Conform}$. And the conform refine process
          requires the mesh should be generated by corresponding mesh generator which is defined in the same input file.
          However, this is the most stable mesh refinement procedure. The
$\mathbf{REFINE.Hierarchical}$ is the
          new mesh refine and coarsen mechanism introduced into GENIUS. It supports all the elements and regardless mesh
          generators. This method will generate hanging node on the side of elements with different refinement level.
          User should ensure that the hanging node be far away from pn junction of the device. Or convergence problem
          may occur. Generally, refine by potential has the best effect.
\par
\subsubsection{Example}
\par
\begin{lstlisting}[style=GeniusCode]
REFINE.U Step=1

REFINE.C Variable=potential cell.fraction=0.3

REFINE.H Variable=potential cell.refine.fraction=0.3 \
         cell.coarsen.fraction=0.1
\end{lstlisting}
\section{External Sources}
For simulation the transient response of device, GENIUS supports several types of voltage and current
      source. The original models of these sources come from SPICE, a famous circuit simulation program. Several sources
      may be defined in one disk file. And the placement of these definitions are not critical. The sources can be
      assigned to electrode by $\mathbf{ATTACH}$ statement when needed.
\par
\subsection{VSOURCE}
\index{VSOURCE command}The $\mathbf{VSOURCE}$
command defines a voltage source.
\par
\begin{lstlisting}[style=GeniusCmd]
VSOURCE
  ID=str   [ TDelay = num ]
  [ Type = (VDC|VSin|VExp|VPulse|VShell) ]

DC Source
  { VConst=num } |

Sinusoidal Source
  { VAmp=num VFreq=num } |

Exponential Source
  { VHi=num VLo=num TRC=num TFD=num TFC=num  } |

Pulse Source
  { VHi=num VLo=num Tr=num Tf=num Pw=num Pr=num } |

User-defined Source
  { DLL=str Function=str }
\end{lstlisting}
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
\multicolumn{5}{l}{\textbf{General Parameters}}
\\
 $\mathbf{Type}$
& enum
& Selects the type of voltage source. The following types are available: DC source,
                  sinusoidal source, exponential source, pulse source and user-defined source.
\par
& $\mathbf{VDC}$
& none
\\
 $\mathbf{ID}$
& string
& Declares the name of the source.
& none
& none
\\
 $\mathbf{TDelay}$
& numerical
& Delay time before the source voltage is applied.
& none
& none\\
\multicolumn{5}{l}{\textbf{DC Source Parameters}}
\\
 $\mathbf{VConst}$
& numerical
& Constant voltage.
& 0.0
& $\Volt$\\
\multicolumn{5}{l}{\textbf{Sinusoidal Source Parameters}}
\\
 $\mathbf{VAmp}$
& numerical
& Amplitude of the sinusoidal source.
& 0.0
& $\Volt$
\\
 $\mathbf{VFreq}$
& numerical
& Frequency of the sinusoidal source
& none
& $\Hertz$\\
\multicolumn{5}{l}{\textbf{Exponential Source Parameters}}
\\
 $\mathbf{VHi}$
& numerical
& Upper bound of exponential voltage waveform.
& 0.0
& $\Volt$
\\
 $\mathbf{VLo}$
& numerical
& Lower bound of exponential voltage waveform.
& 0.0
& $\Volt$
\\
 $\mathbf{TRC}$
& numerical
& Rising edge time constant.
& none
& $\Second$
\\
 $\mathbf{TFD}$
& numerical
& Delay time before the falling phase starts. The length of the rising phase is thus
$\mathbf{TFD}$-$\mathbf{TDelay}$.
& none
& $\Second$
\\
 $\mathbf{TFC}$
& numerical
& Falling edge time constant.
& none
& $\Second$\\
\multicolumn{5}{l}{\textbf{Pulse Source Parameters}}
\\
 $\mathbf{VHi}$
& numerical
& High-voltage level of the pulses.
& 0.0
& $\Volt$
\\
 $\mathbf{VLo}$
& numerical
& Lower-voltage level of the pulses.
& 0.0
& $\Volt$
\\
 $\mathbf{Tr}$
& numerical
& Rising edge time constant.
& 1e-12
& $\Second$
\\
 $\mathbf{Tf}$
& numerical
& Falling edge time constant.
& 1e-12
& $\Second$
\\
 $\mathbf{Pw}$
& numerical
& Pulse width.
& 0.0
& $\Second$
\\
 $\mathbf{Pr}$
& numerical
& Repeating period of the pulse train.
& 0.0
& $\Second$\\
\multicolumn{5}{l}{\textbf{User-defined Source Parameters}}
\\
 $\mathbf{DLL}$
& string
& Name of the dynamically loadable library file that contains the user-defined source.
& none
& none
\\
 $\mathbf{Function}$
& string
& Function name of the source in the DLL file.
& none
& none\\
\end{longtable}

\subsubsection{Description}
GENIUS supports user defined voltage and current source by loading shared object (.so) file. The file
          which contains a user defined voltage source should have the function as follow. GENIUS will pass the argument
          time in the unit of second to the function \IdentifierType{vsrc\_name}
and get voltage value in the unit of
          volt. The current source function is almost the same except the unit of current is
\Ampere.
\par
\begin{lstlisting}[language={C++}]
double vsrc_name(double time)
{
   /* calculate the voltage amplitude */
   return vsrc_amplitude;
}
double isrc_name(double time)
{
    /* calculate the current amplitude */
    return isrc_amplitude;
}
\end{lstlisting}
The c code should be linked with $\mathbf{-shared}$ and $\mathbf{-fPIC}$
option
          as:
\par
\begin{lstlisting}[language=sh]
gcc -shared -fPIC -o foo.so foo.c -lm
\end{lstlisting}
The \FilenameType{foo.so} file should be put in the same directory as input file.
\par
\subsubsection{Example}
\begin{lstlisting}[style=GeniusCode]
vsource Type=VDC    ID=GND  Tdelay=0 Vconst=0

vsource Type=VDC    ID=VCC  Tdelay=0 Vconst=5

vsource Type=VSIN   ID=Vs   Tdelay=1e-6 Vamp=0.1 Freq=1e6

vsource Type=VEXP   ID=V1   Tdelay=0 TRC=1e-6 TFD=1e-6 \
        TFC=1e-6 Vlo=0 Vhi=1

vsource Type=VPULSE ID=V2   Tdelay=0 Tr=1e-9 Tf=1e-9 \
        Pw=5e-6 Pr=1e-5 Vlo=0 Vhi=1

vsource Type=VSHELL ID=VGauss  DLL=foo.so Func=vsrc_gauss
\end{lstlisting}
\par
\subsection{ISOURCE}
\index{ISOURCE command}The $\mathbf{ISOURCE}$
command defines a voltage source.
\par
\begin{lstlisting}[style=GeniusCmd]
ISOURCE
  ID=str  [ Type = (IDC|ISin|IExp|IPulse|IShell) ]
  [ TDelay = num ]

DC Source
  { IConst=num } |

Sinusoidal Source
  { IAmp=num IFreq=num } |

Exponential Source
  { IHi=num ILo=num TRC=num TFD=num TFC=num  } |

Pulse Source
  { IHi=num ILo=num Tr=num Tf=num Pw=num Pr=num } |

User-defined Source
  { DLL=str Function=str }
\end{lstlisting}
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
\multicolumn{5}{l}{\textbf{General Parameters}}
\\
 $\mathbf{Type}$
& enum
& Selects the type of current source. The following types are available: DC source,
                  sinusoidal source, exponential source, pulse source and user-defined source.
\par
& $\mathbf{VDC}$
& none
\\
 $\mathbf{ID}$
& string
& Declares the name of the source.
& none
& none
\\
 $\mathbf{TDelay}$
& numerical
& Delay time before the source is applied.
& none
& none\\
\multicolumn{5}{l}{\textbf{DC Source Parameters}}
\\
 $\mathbf{IConst}$
& numerical
& Constant current.
& 0.0
& $\Volt$\\
\multicolumn{5}{l}{\textbf{Sinusoidal Source Parameters}}
\\
 $\mathbf{IAmp}$
& numerical
& Amplitude of the sinusoidal source.
& 0.0
& $\Volt$
\\
 $\mathbf{IFreq}$
& numerical
& Frequency of the sinusoidal source
& none
& $\Hertz$\\
\multicolumn{5}{l}{\textbf{Exponential Source Parameters}}
\\
 $\mathbf{IHi}$
& numerical
& Upper bound of exponential current waveform.
& 0.0
& $\Volt$
\\
 $\mathbf{ILo}$
& numerical
& Lower bound of exponential current waveform.
& 0.0
& $\Volt$
\\
 $\mathbf{TRC}$
& numerical
& Rising edge time constant.
& none
& $\Second$
\\
 $\mathbf{TFD}$
& numerical
& Delay time before the falling phase starts. The length of the rising phase is thus
$\mathbf{TFD}$-$\mathbf{TDelay}$.
& none
& $\Second$
\\
 $\mathbf{TFC}$
& numerical
& Falling edge time constant.
& none
& $\Second$\\
\multicolumn{5}{l}{\textbf{Pulse Source Parameters}}
\\
 $\mathbf{IHi}$
& numerical
& High-current level of the pulses.
& 0.0
& $\Volt$
\\
 $\mathbf{ILo}$
& numerical
& Lower-current level of the pulses.
& 0.0
& $\Volt$
\\
 $\mathbf{Tr}$
& numerical
& Rising edge time constant.
& 1e-12
& $\Second$
\\
 $\mathbf{Tf}$
& numerical
& Falling edge time constant.
& 1e-12
& $\Second$
\\
 $\mathbf{Pw}$
& numerical
& Pulse width.
& 0.0
& $\Second$
\\
 $\mathbf{Pr}$
& numerical
& Repeating period of the pulse train.
& 0.0
& $\Second$\\
\multicolumn{5}{l}{\textbf{User-defined Source Parameters}}
\\
 $\mathbf{DLL}$
& string
& Name of the dynamically loadable library file that contains the user-defined source.
& none
& none
\\
 $\mathbf{Function}$
& string
& Function name of the source in the DLL file.
& none
& none\\
\end{longtable}

\subsubsection{Example}
\begin{lstlisting}[style=GeniusCode]
ISource Type=IDC    ID=I1 Tdelay=0 Iconst=5

Isource Type=ISIN   ID=I2 Tdelay=0 Iamp=0.1 Freq=1e6

Isource Type=IEXP   ID=I3 Tdelay=0 TRC=1E-6 TFD=3E-6 \
        TFC=1E-6 Ilo=0 Ihi=1

Isource Type=IPULSE ID=I4 Tdelay=0 Tr=1E-9 Tf=1E-9 \
        Pw=5E-6 Pr=1E-5 Ilo=0 Ihi=1
\end{lstlisting}
\subsection{PARTICLE}
\index{PARTICLE command}
\par
\begin{lstlisting}[style=GeniusCmd]
PARTICLE

From scatter data file
  Profile = ( FromFile2D | FromFile3D ) Profile.File=<<str>>
  [Transform.xx=<<num>>] [Transform.xy=<<num>>] [Transform.xz=<<num>>]
  [Transform.yx=<<num>>] [Transform.yy=<<num>>] [Transform.yz=<<num>>]
  [Transform.zx=<<num>>] [Transform.zy=<<num>>] [Transform.zz=<<num>>]
  [Translate.x=<<num>>]  [Translate.y=<<num>>]  [Translate.z=<<num>>]

From analytic expression
  Profile = Expression LET=<<num>>

From particle track
  Profile = Track  Profile.File=<<str>>

  [Energy.Eff=<<num>>]   [t0=<<num>> ] [tmax=<<num>>] [ t.Char=<<num>> ]
\end{lstlisting}
\par
\subsubsection{Parameters}
\par
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
 $\mathbf{Profile}$
& enum
& Type of particle profile input.
& $\mathbf{none}$
& none
\\
 $\mathbf{Transform}$
& numerical
& The transformation matrix applied to the coordinates imported from the input file. The
                  final coordinates are obtained from $\mathbf{Transform}$*{\ttsl
location} + $\mathbf{Translate}$.
\par
& I
& none
\\
 $\mathbf{Translate}$
& enum
& The translation vector applied to the input coordinates.
& 0
& none
\\
 $\mathbf{Energy.Eff}$
& numerical
& The energy loss for each generated electron-hole pair.
& 3.6
& $\eVolt$
\\
 $\mathbf{t0}$
& numerical
& The starting time when high-energy particles penetrates the device.
& 0.0
& $\Second$
\\
 $\mathbf{tmax}$
& numerical
& The time instant when electron-hole pair generation rate reaches its maximum.
& 0.0
& $\Second$
\\
 $\mathbf{t.Char}$
& numerical
& The variance ($\sigma$) of the Gaussian decay of carrier generation
                  rate.
& 1e-12
& $\Second$\\
\end{longtable}

\subsubsection{Description}
There are several ways to specify the energy deposit of a particle: by scatter data file, by analytic
          express and by particle track.
\par
The input data file must be in plain text, with numerical values separated by white spaces. Each line
          contains the coordinates and the energy deposition at that position. For 2D profile, each line has 3 values,
          while for 3D profile, each line has 4 values. The coordinates are in the unit of
$\uMeter$, while the energy deposition is in the unit of $eV\mu{}m^{-3}$.
\par
\subsubsection{Examples}
\begin{lstlisting}[style=GeniusCode]
PARTICLE Profile=FromFile3D Profile.File="particle.dat" \
         tmax=2e-12 t.char=2e-12
\end{lstlisting}
\subsection{LIGHT}
\index{Light command}
\par
\begin{lstlisting}[style=GeniusCmd]
LIGHT
  { SpectrumFile=<<str>> | ( Lambda=<<num>> Intensity=<<num>> [Eta=<<num>>] ) }
  Profile = ( FromFile2D | FromFile3D )
  [ Profile.File=<<str>> ] [ SkipLine=<<num>> ]
  [ LUnit = (m|cm|um|nm) ] [ FUnit = (m|cm|um|nm) ]
  [Transform.xx=<<num>>] [Transform.xy=<<num>>] [Transform.xz=<<num>>]
  [Transform.yx=<<num>>] [Transform.yy=<<num>>] [Transform.yz=<<num>>]
  [Transform.zx=<<num>>] [Transform.zy=<<num>>] [Transform.zz=<<num>>]
  [Translate.x=<<num>>]  [Translate.y=<<num>>]  [Translate.z=<<num>>]
\end{lstlisting}
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
$\mathbf{Profile}$
& enum
& Type of field profile input.
& $\mathbf{none}$
& none
\\
 $\mathbf{Lambda}$
& numerical
& Wavelength of the monochromatic light.
& $\mathbf{0.532}$
& $\uMeter$
\\
 $\mathbf{Intensity}$
& numerical
& Intensity of the monochromatic light.
& $\mathbf{0.0}$
& $\Watt\Per\Square\cMeter$
\\
 $\mathbf{Eta}$
& numerical
& Quantum efficiency of carrier generation for the monochromatic light. If not explicitly
                    specified, Genius will automatically calculate the quantum efficiency using the bandgap of the
                    material.
& $\mathbf{auto}$
& none
\\
 $\mathbf{SpectrumFile}$
& string
& Filename of the spectrum file. This file should describe the wavelength and intensity at each
                    frequency in the spectrum.
& $\mathbf{none}$
& none
\\
 $\mathbf{Profile.File}$
& enum
& Filename of the field solution data file. When a spectrum file is provided, the provided
                    filename extension is appended to the field solution filename.
& $\mathbf{none}$
& none
\\
 $\mathbf{SkipLine}$
& integer
& Skip the first $\mathbf{SkipLine}$ number of lines in the field data
                    file.
& 0
& none
\\
 $\mathbf{LUnit}$
& enum
& Length unit used for node coordinates in the field data file.
& $\mathbf{um}$
& none
\\
 $\mathbf{FUnit}$
& enum
& Length unit used in E-field value. The voltage unit is always Volt.
& $\mathbf{um}$
& none
\\
 $\mathbf{Transform}$
& numerical
& The transformation matrix applied to the coordinates imported from the input file. The
                    final coordinates are obtained from $\mathbf{Transform}$*{\ttsl
location} + $\mathbf{Translate}$.
\par
& I
& none
\\
 $\mathbf{Translate}$
& enum
& The translation vector applied to the input coordinates.
& 0
& none\\
\end{longtable}

\par
\subsubsection{Description}
\marginhead{Spectrum file}With the spectrum file we can load the field data at multiple wavelengths in the same
$\mathbf{LIGHT}$ command. Each line in the spectrum file should contain the following
            columns
\begin{compactitem}
\item A filename extension for the field data file. Suppose $\mathbf{Profile.File}$
is \FilenameType{diode1}, and the extension is \FilenameType{3290}, Genius will try to load
                  the field data from the file \FilenameType{diode1.3290}.
\par
\item The wavelength in the unit of micro-meter.
\par
\item Intensity density (per unit wavelength) at this wavelength. The unit is
$\Watt\Per\Square\cMeter\Per\uMeter$. Note that this differs from the
$\mathbf{intensity}$ parameter for monochromatic light.
\par
\item (Optional) quantum efficiency for carrier generation. If not explicitly specified, Genius will
                  automatically calculate the quantum efficiency using the bandgap of the material.
\par
\end{compactitem}
\par
\par
A sample spectrum file is listed below.
\par
\begin{lstlisting}[language=sh]
# ext   lambda    intensity
3290    0.912     0.2
3145    0.954     0.5
3000    1.00      0.4
2855    1.05      0.3
2710    1.11      0.2
2565    1.17      0.2
2420    1.24      0.1
\end{lstlisting}
\marginhead{Optical Carrier Generation}HFSS assumes by default that the incident wave has E-field strength of
$E_0=1 V/m$, which corresponds to the incident intensity of
\par
\par
\begin{equation}
P_0 = \frac{1}{2} \epsilon_0 c_0 {E_0}^2.
\end{equation}
We need to scale the E-field in the solution according to the user-specified incident intensity.
\par
If the user does not supply the quantum efficiency value, Genius will calculate with the following
          assumption
\par
\begin{equation}
\eta = \mathop{floor}\nolimits ( \frac{E_g}{h \nu} ).
\end{equation}
where the \emph{floor} function round to largest integral value not
          greater than the argument. The carrier generation is finally calculated with
\par
\begin{equation}
G = \eta \frac{\pi \epsilon_0 \left(-\epsilon^{\prime\prime}_{r}\right)} {h} E^2.
\end{equation}
HFSS places a descriptive heading in each spectrum file, we shall skip that line.
\par
\marginhead{Field Data File}The input data file must be in plain text, with numerical values separated by white spaces. Each line
            contains the coordinates and the E-field strength of the EM wave at that position. For 2D profile, each line
            has 3 values, while for 3D profile, each line has 4 values. The unit of the coordinates is specified by
$\mathbf{LUnit}$, and the unit of the E-field is specified by $\mathbf{FUnit}$.
\par
\par
\subsubsection{Examples}
\begin{lstlisting}[style=GeniusCode]
LIGHT     SpectrumFile=diode1 Profile.File=diode1 \
          Profile=fromfile3d LUnit=m FUnit=m SkipLine=1
\end{lstlisting}
\subsection{ENVELOP}
\index{ENVELOP command}The $\mathbf{ENVELOP}$
command defines an envelop in time, which is used to modulate light
        source. The light source can be introduced by $\mathbf{LIGHT}$
command and $\mathbf{RAYTRACE}$ command. User can specify the envelop of light source at the
$\mathbf{SOLVE}$ command.
\par
\begin{lstlisting}[style=GeniusCmd]
ENVELOP
  ID = str
  [ Type = (Uniform|Gaussian|Pulse|Expression|Shell) ]
  [ TDelay = num ]

Uniform envelop
  { Amplitude=num } |

Gaussian envelop
  { Amplitude=num T0=num Tao=num} |

Pulse envelop
  { Amplitude.high=num Amplitude.low=num
    Tr=num Tf=num Pw=num Pr=num } |

User-defined envelop by expression
  { Expression=str }

User-defined envelop by dynamic loadable library
  { DLL=str Function=str }
\end{lstlisting}
\par
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
\multicolumn{5}{l}{\textbf{General Parameters}}
\\
 $\mathbf{Type}$
& enum
& Selects the type of envelop. The following types are available: Uniform, Gaussian, Pulse
                  and user-defined envelop.
\par
& $\mathbf{Uniform}$
& none
\\
 $\mathbf{ID}$
& string
& Declares the name of the envelop.
& none
& none
\\
 $\mathbf{TDelay}$
& numerical
& Delay time before the envelop is applied.
& none
& none\\
\multicolumn{5}{l}{\textbf{Uniform Envelop Parameters}}
\\
 $\mathbf{Amplitude}$
& numerical
& Constant amplitude.
& 1.0
& none\\
\multicolumn{5}{l}{\textbf{Gaussian Envelop Parameters}}
\\
 $\mathbf{Amplitude}$
& numerical
& Amplitude of Gaussian waveform.
& 1.0
& none
\\
 $\mathbf{T0}$
& numerical
& The time when Gaussian waveform reaches its max.
& 0.0
& $\Second$
\\
 $\mathbf{Tao}$
& numerical
& The characteristic time of Gaussian waveform.
& 1e-12
& $\Second$\\
\multicolumn{5}{l}{\textbf{Pulse Envelop Parameters}}
\\
 $\mathbf{Amplitude.high}$
& numerical
& High level of the pulses.
& 1.0
& $\Volt$
\\
 $\mathbf{Amplitude.low}$
& numerical
& Lower level of the pulses.
& 0.0
& $\Volt$
\\
 $\mathbf{Tr}$
& numerical
& Rising edge time constant.
& 1e-12
& $\Second$
\\
 $\mathbf{Tf}$
& numerical
& Falling edge time constant.
& 1e-12
& $\Second$
\\
 $\mathbf{Pw}$
& numerical
& Pulse width.
& 0.0
& $\Second$
\\
 $\mathbf{Pr}$
& numerical
& Repeating period of the pulse train.
& 0.0
& $\Second$\\
\multicolumn{5}{l}{\textbf{User-defined Envelop Parameters}}
\\
 $\mathbf{DLL}$
& string
& Name of the dynamically loadable library file that contains the user-defined source.
& none
& none
\\
 $\mathbf{Function}$
& string
& Function name of the source in the DLL file.
& none
& none\\
\end{longtable}
\subsubsection{Examples}
\begin{lstlisting}[style=GeniusCode]
ENVELOP   ID=gaussian_pulse Type=Gaussian amplitude=1e3 tdelay=0 t0=5e-12 tao=1e-12
\end{lstlisting}
\subsection{CIRCUIT}
\index{CIRCUIT command}The $\mathbf{CIRCUIT}$
command defines a circuit netlist (in SPICE syntax) for mixed-mode
        simulation.
\par
\begin{lstlisting}[style=GeniusCmd]
CIRCUIT
  Netlist = <<str>>
\end{lstlisting}
\par
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
 $\mathbf{Netlist}$
& string
& Path to the netlist file. The netlist should be in SPICE format.
\par
& $\mathbf{none}$
& none\\
\end{longtable}
\section{Boundary Conditions}
\subsection{Boundary and Contact}
\index{BOUNDARY command}\index{CONTACT command}The
$\mathbf{BOUNDARY}$ statement sets boundary information to representing faces of the
        device mesh. GENIUS now fully support electrode region (the material of this region should be metal or poly-Si).
        One should use $\mathbf{CONTACT}$ statement to specify the electrode type of this region(s).
\par
\begin{lstlisting}[style=GeniusCmd]
BOUNDARY
    ID=<<str>>
    Type = ( OhmicContact | SchottkyContact | SolderPadContact |
             GateContact | SimpleGateContact |
             InsulatorInterface|
             HeteroJunction | NeumannBoundary )

  Ohmic Contact
    [ Res=<<num>> ] [ Cap=<<num>> ] [ Ind=<<num>> ]
    [ Heat.Transfer=<<num>> ] [ Ext.Temp=<<num>> ]

  Schottky Contact
    [ WorkFunction=<<num>> ]
    [ Res=<<num>> ] [ Cap=<<num>> ] [ Ind=<<num>> ]
    [ Heat.Transfer=<<num>> ] [ Ext.Temp=<<num>> ]

  Gate Contact
    [ WorkFunction=<<num >>]
    [ Res=<<num>> ] [ Cap=<<num>> ] [ Ind=<<num>> ]
    [ Heat.Transfer=<<num>> ] [ Ext.Temp=<<num>> ]

  SolderPad Contact
    [ Res=<<num>> ] [ Cap=<<num>> ] [ Ind=<<num>> ]
    [ Heat.Transfer=<<num>> ] [ Ext.Temp=<<num>> ]

  Simple Gate Contact
    [ WorkFunction=<<num >>] [ QF=<<num>> ]
    [ Res=<<num>> ] [ Cap=<<num>> ] [ Ind=<<num>> ]
    [ Thickness=<<num>> ] [ eps=<<num>> ]
    [ Heat.Transfer=<<num>> ] [ Ext.Temp=<<num>> ]

  Insulator Interface
    [ QF=<<num>> ]

  HeteroJunction
    [ QF=<<num>> ]

  NeumannBoudary
    [ Heat.Transfer=<<num>> ] [ Ext.Temp=<<num>> ]

Contact
    ID=<<str>> Type = (OhmicContact|SchottkyContact|
                   GateContact|FloatMetal)

  Ohmic Contact
    [ Res=<<num>> ] [ Cap=<<num>> ] [ Ind=<<num>> ]
    [ Heat.Transfer=<<num>> ] [ Ext.Temp=<<num>> ]

  SchottkyContact
    [ WorkFunction=<<num>> ]
    [ Res=<<num>> ] [ Cap=<<num>> ] [ Ind=<<num>> ]
    [ Heat.Transfer=<<num>> ] [ Ext.Temp=<<num>> ]

  Gate Contact
    [ WorkFunction=<<num >>]
    [ Res=<<num>> ] [ Cap=<<num>> ] [ Ind=<<num>> ]
    [ Heat.Transfer=<<num>> ] [ Ext.Temp=<<num>> ]

  Floating Metal
    [ QF=<<num>> ]
\end{lstlisting}
\par
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
 $\mathbf{Type}$
& enum
& This parameter declares which type of boundary condition is defined here.
\par
& none
& none
\\
 $\mathbf{ID}$
& string
& A unique string which identifies the corresponding face.
& none
& none
\\
 $\mathbf{Res}$
& numerical
& The lumped resistance for the electrode.
& 0.0
& $\Ohm$
\\
 $\mathbf{Cap}$
& numerical
& The lumped capacitance for the electrode.
& 0.0
& $\Farad$
\\
 $\mathbf{Ind}$
& numerical
& The lumped inductance for the electrode.
& 0.0
& $\Henry$
\\
 $\mathbf{WorkFunction}$
& numerical
& The workfunction of the Schottky contact or gate material.
& 0.0
& $\eVolt$
\\
 $\mathbf{QF}$
& numerical
& For InsulatorContact and InsulatorInterface bc: The surface charge density of
                  semiconductor-insulator interface.
& 0.0
& $cm^{-2}$
\\
 $\mathbf{QF}$
& numerical
& For Heterojunction bc: The surface charge density of heterojunction.
& 0.0
& $cm^{-2}$
\\
 $\mathbf{QF}$
& numerical
& For FloatMetal bc: The free charge per micron in Z dimension.
& 0.0
& $C{}\times{} {\uMeter}^{-1}$
\\
 $\mathbf{Thickness}$
& numerical
& The thickness of SiO\low{2} layer.
& 2e-7
& $\cMeter$
\\
 $\mathbf{eps}$
& numerical
& The relative permittivity of SiO\low{2} layer.
& 3.9
& none
\\
 $\mathbf{Heat.Transfer}$
& numerical
& The thermal conductance of the surface.
& see below
& $\Watt\times cm^{-2} {\Kelvin}^{-1}$
\\
 $\mathbf{Ext.Temp}$
& numerical
& The external temperature at the surface.
& see below
& $\Kelvin$\\
\end{longtable}

\subsubsection{Description}
Five "electrode" boundary conditions are supported by GENIUS. The names are ended with
$\mathbf{Contact}$. The $\mathbf{OhmicContact}$ and $\mathbf{SchottkyContact}$
electrodes have current flow in both steady state and transient situations. While
$\mathbf{GateContact}$ and $\mathbf{SimpleGateContact}$(a simplified MOSFET Gate
          boundary condition) only have displacement current in transient situation.
$\mathbf{SolderPadContact}$ also has current flow in steady state and transient situations. The
$\mathbf{OhmicContact}$, $\mathbf{SchottkyContact}$ and $\mathbf{SimpleGateContact}$
are boundaries on surface of semiconductor region. $\mathbf{GateContact}$
should be the surface of insulator region and $\mathbf{SolderPadContact}$
is the surface of a metal region.
\par
Genius supports five interfaces which can be set automatically: semiconductor-insulator interface
          ($\mathbf{InsulatorInterface}$), semiconductor-electrode interface(set to
$\mathbf{OhmicContract}$ as default), interface between different semiconductor material
          ($\mathbf{Heterojunction}$) and interface between same semiconductor material
          ($\mathbf{Homojunction}$). These boundaries can be set automatically by Genius if user didn't set
          them explicitly. However, the electrode-insulator interface, may have several situations: Gate to Oxide
          interface, $\mathbf{FloatMetal}$ to Oxide interface or Source/Drain electrode to Oxide interface.
          As a result, this interface can only be set correctly when electrode type is known. Please refer to the
          following $\mathbf{CONTACT}$ statement.
\par
GENIUS can build region with metal or poly-Si material to form an electrode. Which means, i.e. for
$\mathbf{OhmicContact}$ bc, one can simply specify a segment as Ohmic bc or build an electrode
          region as Ohmic electrode. Since Version 0.45.03, GENIUS considers electrode region, semiconductor region and
          insulator region during calculation. As a result, GENIUS added
$\mathbf{CONTACT}$ statement for fast
          boundaries specification of electrode region. At present, GENIUS support electrode with the type of Ohmic,
          Schottky, Gate and Floating-Metal. All the electrode should be specified explicitly and GENIUS will set
          corresponding boundaries automatically.
\par
The $\mathbf{ID}$ parameter of $\mathbf{BOUNDARY}$ statement is limited to face
          label. And The $\mathbf{ID}$ parameter of $\mathbf{CONTACT}$
statement is limited to
          region name.
\par
The NeumannBoundary, which is the default boundary type for all the non-interface segments, are set
          automatically at the outer surface of a region.
\par
The thermal boundary conditions at outer surfaces of the device and the interface with electrode regions
          are specified by the $\mathbf{Heat.Transfer}$ and $\mathbf{Ext.Temp}$
parameters. The
          default external temperature at the boundary is the external temperature set in the
$\mathbf{GLOBAL}$ command. The default value for heat conductance varies with the types of boundary conditions. For
$\mathbf{OhmicContact}$, $\mathbf{SchottkyContact}$ and $\mathbf{Gatecontact}$, the default heat conductance is
$10^3
          \Watt\times cm^{-2} {\Kelvin}^{-1}$. For $\mathbf{NeumannBoundary}$, the heat
          resistance is default to zero.
\par
\subsubsection{Example}
\begin{lstlisting}[style=GeniusCode]
BOUNDARY Type=SimpleGateContract  ID=SiSiO2 Res=0 Cap=0 Ind=0 \
         Thickness=1e-6 Eps=3.9 WorkFunction=4.7 QF=0

BOUNDARY Type=InsulatorInterface ID=IFACE QF=0

BOUNDARY Type=GateContract       ID=GATE   Res=0 Cap=0 Ind=0 \
         WorkFunction=4.7

BOUNDARY Type=NeumannBoundary    ID=WALL   Heat.Transfer=0 \
         EXT.Temp=300

BOUNDARY Type=SchottkyContract   ID=sgate  Res=0 Cap=0 Ind=0 \
         VBarrier=0.8

BOUNDARY Type=OhmicContract     ID=OMANODE Res=0 Cap=0 Ind=0

BOUNDARY Type=SolderPad         ID=CATHODE Res=0 Cap=0 Ind=0
\end{lstlisting}
\subsection{ATTACH}
\index{ATTACH command}The $\mathbf{ATTACH}$
command is used to add voltage or current sources to the electrode
        boundary. The statement first clears all the sources connected to the specified electrode and then adds
        source(s) defined by $\mathbf{VApp}$ or $\mathbf{IApp}$ parameter. If two or more
        sources are attached to the same electrode, the net effect is the superposition of all sources. However, the
        sources attached to one electrode must have the same type.
\begin{lstlisting}[style=GeniusCmd]
ATTACH
  Electrode=str { VApp=str | IApp=str } [ { VApp=str | IApp=str } ... ]
\end{lstlisting}
\par
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
\multicolumn{5}{l}{\textbf{Setup Loadable Physical Models}}
\\
 $\mathbf{Electrode}$
& string
& Electrode where the external source is attached. Must be a valid ID of a electrical contact
                    specified by the $\mathbf{BOUNDARY}$ or $\mathbf{CONTACT}$
commands.
& none
& none
\\
 $\mathbf{VApp}$
& string
& ID of the voltage source.
& none
& none
\\
 $\mathbf{IApp}$
& string
& ID of the current source.
& none
& none\\
\end{longtable}

\par
\subsubsection{Description}
If electrode is attached with voltage source(s), the R, C and L defined by
$\mathbf{BOUNDARY}$ statement will affect later simulation. But solver will ignore R and L when the electrode stimulated by
          current source(s). Please refer to \figref{fig:CmdRef:Attach:Electrode},
p. \pageref{fig:CmdRef:Attach:Electrode}.
\par
Several voltage sources or current sources can be attached to the same electrode by multi-
$\mathbf{Vapp}$ or multi-$\mathbf{ Iapp}$ parameter. However, both the voltage source
          and current source attach to the same electrode is invalid. Only Ohmic, Schottky and SolderPad electrodes can
          be attached by current source(s). And the positive direction of current is flow into the electrode.
\par
If no source attached explicitly, the electrode is set to be attached to ground (0V VDC).
\par

\begin{figure}[H]
\caption{\label{fig:CmdRef:Attach:Electrode}Voltage and current boundary.}
%\includegraphics[width=0.8\textwidth]{plotCmdRef/electrode.png]}
\end{figure}

\subsubsection{Example}
\begin{lstlisting}[style=GeniusCode]
ATTACH Electrode=Anode Vapp=V5V Vapp=Vs
ATTACH Electrode=Base  Iapp=Ib
\end{lstlisting}
\section{Fabrication Process}
\par
\subsection{DOPING}
\index{DOPING command}The DOPING command selects the mode of doping profile specification. Only analytic doping profile
        is currently implemented.
\par
\begin{lstlisting}[style=GeniusCmd]
Doping Analytic
\end{lstlisting}
\subsection{Analytic PROFILE}
\index{PROFILE command}The PROFILE command specifies the doping profile. Uniform and analytic doping profiles are
        supported.
\par
\begin{lstlisting}[style=GeniusCmd]
PROFILE[.DOPING]
    [ ID=<<str>> ]
    Type = (Uniform|Analytic|Analytic2|File) Ion = (Donor|Acceptor|Custom)

  Uniform Profile Parameters
    N.Peak=<<num>>
    [ x.min=<<num>> ] [ x.max=<<num>> ] [ y.min=<<num>> ] [ y.max=<<num>> ]
    [ z.min=<<num>> ] [ z.max=<<num>> ]

  Anaylitic Profile Parameters
    { N.Peak=<<num>> | Dose=<<num>> }
    [ x.min=<<num>> ] [ x.max=<<num>> ] [ y.min=<<num>> ] [ y.max=<<num>> ]
    [ z.min=<<num>> ] [ z.max=<<num>> ]
    { Y.Char=<<num>> | Y.Junction=<<num>> } [ Y.ErfC=<<bool>> ]
    { X.Char=<<num>> | XY.Ratio=<<num>> } [ X.ErfC=<<bool>> ]
    { Z.Char=<<num>> | ZY.Ratio=<<num>> } [ Z.ErfC=<<bool>> ]

  Anaylitic2 Profile Parameters
    { N.Peak=<<num>> }
    {
      mask.polygon=<<anum>> |
      { mask.x=<<num>> | mask.y=<<num>> | mask.z=<<num>> }
      [ mask.xmin=<<num>> ] [ mask.xmax=<<num>> ]
      [ mask.ymin=<<num>> ] [ mask.ymax=<<num>> ]
      [ mask.zmin=<<num>> ] [ mask.zmax=<<num>> ]
    }
    [ implant.rmin=<<num>> ] [ implant.rmax=<<num>> ]
    [ implant.theta=<<num>> ] [ implant.phi=<<num>> ]
    [ depth.char=<<num>> ] [ lateral.char=<<num>> ]
    [ resolution=<<num>> ]

  Data File Parameters
    File=<<str>> [ SkipLine=<<num>> ]
    [ Axes= (x|y|xy|xz|yz|xyz) ]
    [ LUnit = (m|cm|um|nm) ]
    [Transform.xx=<<num>>] [Transform.xy=<<num>>] [Transform.xz=<<num>>]
    [Transform.yx=<<num>>] [Transform.yy=<<num>>] [Transform.yz=<<num>>]
    [Transform.zx=<<num>>] [Transform.zy=<<num>>] [Transform.zz=<<num>>]
    [Translate.x=<<num>>]  [Translate.y=<<num>>]  [Translate.z=<<num>>]
\end{lstlisting}
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
\multicolumn{5}{l}{\textbf{General Parameters}}
\\
 $\mathbf{Type}$
& enum
& Selects the type of doping profile. Doping profile can be $\mathbf{Uniform}$,
                  specified by $\mathbf{Analytic}$ expression, or loaded from a data
$\mathbf{File}$.
\par
& $\mathbf{Uniform}$
& none
\\
 $\mathbf{Ion}$
& enum
& Selects the doping species of the profile. Acceptor, donor and custom species are available.
                  Custom species must bear an ID, so that it can be referenced in other commands (e.g. in PMI trapping
                  model and incomplete ionization model).
& none
& none
\\
 $\mathbf{ID}$
& string
& Identifier of a custom doping profile.
\par
& none
& none
\\
 $\mathbf{x.min}$
& numerical
& Left boundary of the profile. Synonym: $\mathbf{x.left}$.
& 0.0
& $\uMeter$
\\
 $\mathbf{x.max}$
& numerical
& Right boundary of the profile. Synonym: $\mathbf{x.right}$.
& 0.0
& $\uMeter$
\\
 $\mathbf{y.min}$
& numerical
& Top boundary of the profile. Synonym: $\mathbf{y.top}$.
& 0.0
& $\uMeter$
\\
 $\mathbf{y.max}$
& numerical
& Bottom boundary of the profile. Synonym: $\mathbf{y.bottom}$.
& 0.0
& $\uMeter$
\\
 $\mathbf{z.min}$
& numerical
& Front boundary of the profile. Synonym: $\mathbf{z.front}$.
& 0.0
& $\uMeter$
\\
 $\mathbf{z.max}$
& numerical
& Back boundary of the profile. Synonym: $\mathbf{z.back}$.
& 0.0
& $\uMeter$\\
\multicolumn{5}{l}{\textbf{Uniform Profile Parameters}}
\\
 $\mathbf{N.Peak}$
& numerical
& Doping concentration.
& 0.0
& $cm^{-3}$\\
\multicolumn{5}{l}{\textbf{Analytic Profile Parameters}}
\\
 $\mathbf{N.Peak}$
& numerical
& Peak doping concentration. In the box defined by $\mathbf{x.min}$,
$\mathbf{x.max}$, $\mathbf{y.min}$, $\mathbf{y.max}$, $\mathbf{z.min}$,
$\mathbf{z.max}$, the doping is uniformly $\mathbf{N.Peak}$. Outside the box, the doping concentration decays according to the
                  analytic function.
& 0.0
& $cm^{-3}$
\\
 $\mathbf{Dose}$
& numerical
& The dose of the doping concentration, assuming the resulting profile is 1D Gaussian.
& 0.0
& $cm^{-2}$
\\
 $\mathbf{Y.Char}$
& numerical
& Characteristic length in the y direction.
& 0.0
& $\uMeter$
\\
 $\mathbf{Y.Junction}$
& numerical
& Target junction depth.
& 0.0
& $\uMeter$
\\
 $\mathbf{X.Char}$
& numerical
& Characteristic length in the x direction.
& 0.0
& $\uMeter$
\\
 $\mathbf{XY.Ratio}$
& numerical
& The ratio of characteristic length in the x direction against that in the y direction.
& 0.0
& none
\\
 $\mathbf{X.Erfc}$
& bool
& Selects whether to use erfc instead of Gaussian function in the x direction.
& false
& none
\\
 $\mathbf{Z.Char}$
& numerical
& Characteristic length in the z direction.
& 0.0
& $\uMeter$
\\
 $\mathbf{ZY.Ratio}$
& numerical
& The ratio of characteristic length in the z direction against that in the y direction.
& 0.0
& none
\\
 $\mathbf{Z.Erfc}$
& bool
& Selects whether to use erfc instead of Gaussian function in the z direction.
& false
& none\\
\multicolumn{5}{l}{\textbf{Analytic2 Profile Parameters}}
\\
 $\mathbf{mask.poly}$
& numerical-array
& A numerical array specifies vertex location of the polygon mask. Each vertex takes three number
                  as its coordinates. The vertex should be ordered along the loop of polygon. Polygon should be simple,
                  i.e. no self intersection.
& -
& \textdollar{}\textbackslash{}uMeter\textdollar{}
\\
 $\mathbf{mask.x}$
& numerical
& Indicate that doping mask plane is the X=num, for rectangle mask.
& 0.0
& \textdollar{}\textbackslash{}uMeter\textdollar{}
\\
 $\mathbf{mask.y}$
& numerical
& Indicate that doping mask plane is the Y=num, for rectangle mask.
& 0.0
& \textdollar{}\textbackslash{}uMeter\textdollar{}
\\
 $\mathbf{mask.z}$
& numerical
& Indicate that doping mask plane is the Z=num, for rectangle mask.
& 0.0
& \textdollar{}\textbackslash{}uMeter\textdollar{}
\\
 $\mathbf{mask.xmin}$
& numerical
& Left boundary of the rectangle mask
& 0.0
& \textdollar{}\textbackslash{}uMeter\textdollar{}
\\
 $\mathbf{mask.xmax}$
& numerical
& Right boundary of the rectangle mask
& 0.0
& \textdollar{}\textbackslash{}uMeter\textdollar{}
\\
 $\mathbf{mask.ymin}$
& numerical
& Top boundary of the rectangle mask
& 0.0
& \textdollar{}\textbackslash{}uMeter\textdollar{}
\\
 $\mathbf{mask.ymax}$
& numerical
& Top boundary of the rectangle mask
& 0.0
& \textdollar{}\textbackslash{}uMeter\textdollar{}
\\
 $\mathbf{mask.zmin}$
& numerical
& Front boundary of the rectangle mask
& 0.0
& \textdollar{}\textbackslash{}uMeter\textdollar{}
\\
 $\mathbf{mask.zmax}$
& numerical
& Back boundary of the rectangle mask
& 0.0
& \textdollar{}\textbackslash{}uMeter\textdollar{}
\\
 $\mathbf{implant.rmin}$
& numerical
& The minimal depth of implant. Doping concentration keeps constant between min and max doping
                  depth.
& 0.0
& \textdollar{}\textbackslash{}uMeter\textdollar{}
\\
 $\mathbf{implant.rmax}$
& numerical
& The maximal depth of implant. Doping concentration keeps constant between min and max doping
                  depth.
& 0.0
& \textdollar{}\textbackslash{}uMeter\textdollar{}
\\
 $\mathbf{implant.theta}$
& numerical
& Defined as angel between +Y direction and implantation direction.
& 0.0
& degree
\\
 $\mathbf{implant.phi}$
& numerical
& Defined as angel between +X direction and the projection of implantation direction onto XZ
                  plane.
& 0.0
& degree
\\
 $\mathbf{depth.char}$
& numerical
& Characteristic length along the implantation direction.
& 0.1
& \textdollar{}\textbackslash{}uMeter\textdollar{}
\\
 $\mathbf{lateral.char}$
& numerical
& Characteristic length lateral to the implantation direction.
& 0.1
& \textdollar{}\textbackslash{}uMeter\textdollar{}
\\
 $\mathbf{resolution}$
& numerical
& The space resolution factor, minimal sapce equals to $\mathbf{lateral.char}$
divide
                  by this factor.
& 4.0
& none\\
\multicolumn{5}{l}{\textbf{Doping Data File Parameters}}
\\
 $\mathbf{File}$
& string
& Name of the doping concentration data file.
\par
& none
& none
\\
 $\mathbf{Transform}$
& numerical
& The transformation matrix applied to the coordinates imported from the input file. The
                  final coordinates are obtained from $\mathbf{Transform}$*{\ttsl
location} + $\mathbf{Translate}$.
\par
& I
& none
\\
 $\mathbf{Translate}$
& enum
& The translation vector applied to the input coordinates.
& 0
& none
\\
 $\mathbf{SkipLine}$
& integer
& Skip the first $\mathbf{SkipLine}$ number of lines in the data file.
& 0
& none
\\
 $\mathbf{LUnit}$
& enum
& Length unit used for node coordinates in the data file.
& $\mathbf{um}$
& none\\
\end{longtable}

\subsubsection{Analytic Profile Calculation}
When the $\mathbf{Type}$ parameter is set to $\mathbf{Analytic}$, the doping
          profile is calculated with the expression
\par
\begin{equation}
N(x,y) = {\bf N.PEAK} \cdot f_x(x) \cdot f_y(y) \cdot f_z(z),
\end{equation}
where $\mathbf{N.PEAK}$ is the peak doping concentration, and the functions
$f_x(x)$, $f_y(y)$ and $f_z(z)$ describes the variation of doping concentration in the x-, y- and z-directions, respectively.
\par
Two options are currently available for the variation functions, namely the Gauss profile function and
          the Erfc profile function. One can choose the profile function for the x-, y- and z-directions independently.
          When the $\mathbf{X.Erfc}$, $\mathbf{Y.Erfc}$ or $\mathbf{Z.Erfc}$
parameter is enabled, the Erfc function is used in that direction.
\par
The Gauss profile function is defined as
\par
\begin{equation}
f_D(x,y) =  \exp\left[-\left(\frac{y-{\bf D.MIN}}{\bf D.CHAR}\right)^2\right]
            y < {\bf D.MIN} \\   1   {\bf D.MIN}\le y \le {\bf D.MAX} \\
            \exp\left[-\left(\frac{y-{\bf D.MAX}}{\bf D.CHAR}\right)^2\right]   y>{\bf D.MAX} \\
            .
\end{equation}
where ${\bf D} = {\bf X}, {\bf Y}, {\bf Z}$.
\par
The Erfc profile function is defined as
\par
\begin{equation}
N(x,y) = \frac{ erfc\left( \frac{y-{\bf D.MAX}}{\bf D.CHAR} \right) - erfc\left( \frac{y-{\bf
            D.MIN}}{\bf D.CHAR} \right) }{2}.
\end{equation}
If the $\mathbf{XY.Ratio}$ parameter is specified instead of the
$\mathbf{X.Char}$ parameter, $\mathbf{X.Char}$ is calculated with
${\bf X.Char}={\bf XY.Ratio}\times{\bf Y.Char}$. Similar calculation applies to
$\mathbf{ZY.Ratio}$ and $\mathbf{Z.Char}$.
\par
\marginhead{Implant Dose}The $\mathbf{Dose}$ parameter can be used instead of the
$\mathbf{N.Peak}$ parameter to specify the dose of impurities per unit area. In this case, the peak concentration is
            calculated with
\par
\par
\begin{equation}
N.PEAK = \frac{\bf DOSE}{\sqrt{\pi} {\bf Y.CHAR}}.
\end{equation}
\subsubsection{Analytic2 Profile Calculation}
When the $\mathbf{Type}$ parameter is set to $\mathbf{Analytic2}$, the doping
          profile is calculated with a given mask and the implant parameters. A planer rectangle mask or polygon mask
          should be defined as the window of implantation. The implantation is defined by incident angle given by
$\mathbf{implant.theta}$ and $\mathbf{implant.phi}$ and ranges given by
$\mathbf{implant.rmin}$ and $\mathbf{implant.rmax}$, which relative to the mask plane.
          The doping concentration equals to $\mathbf{N.Peak}$ within the range between
$\mathbf{implant.rmin}$ and $\mathbf{implant.rmax}$, and variated as Gauss profile
          function with parameter $\mathbf{depth.char}$ along the doping line outside the range. For lateral
          distribution, a Gauss profile with parameter $\mathbf{lateral.char}$
is assumed. The Genius use a
          ray shooting method to calculate the final doping concentration. The accurate is depended on density of doping
          lines which controlled by parameter$\mathbf{ resolution}$.
\par
\subsubsection{Custom Doping Profile}
When a custom dopant species is desired, the user should set $\mathbf{Ion}$
to $\mathbf{Custom}$, and supply an identifier $\mathbf{ID}$.
\par
\marginhead{Field Data File}The field data file must be in plain text, with numerical values separated by white spaces. For 3D
            doping profile, each line contains four values (x-, y-, and z-coordinate and the doping concentration). For
            2D doping profile, the z-coordinate is not present, and each line contains three values. The unit of the
            coordinates is specified by $\mathbf{LUnit}$, and the unit of the concentration is
$\cMeter^{-3}$. Positive doping concentration indicates Donor ion, while negative doping
            concentration indicates Acceptor ion.
\par
\par
\subsubsection{Example}
\begin{lstlisting}[style=GeniusCode]
Profile.Doping   Type=Analytic Ion=Acceptor \
                 N.Peak=1e18 Y.Min=0.0 Y.Max=0.1 \
                 Y.Char=0.05 XY.Ratio=0.8

Profile.Doping   Type=Analytic2 Ion=Acceptor N.PEAK=1E19 \
                 Mask.poly=[1,0,2,3,0,3,5,0,1,5,0,5,1,0,4] \
                 Implant.rmin=0.0 Implant.rmax=0.3 Implant.theta=0

Profile.Doping   Type=Uniform Ion=Acceptor N.Peak=1e16

Profile.Doping   Type=File File="halo.txt"
\end{lstlisting}
\subsection{MOLE}
\index{MOLE command}The $\mathbf{MOLE}$
command specifies the mole fraction profile of compound materials. For
        binary compound material A\low{x}B\low{1-x}, the mole fraction profile x is needed.
        For tertiary compound material A\low{x}B\low{y}C\low{1-x-y}, both x and y profile are
        needed.
\par
\begin{lstlisting}[style=GeniusCmd]
MOLE
    Region=str
    [ x.min=<<num>> ] [ x.max=<<num>> ] [ y.min=<<num>> ] [ y.max=<<num>> ]
    [ z.min=<<num>> ] [ z.max=<<num>> ]

  Binary Compound Material
    X.Mole=<<num>> ( X.Mole.Slope=<<num>> | X.Mole.End=<<num>> )
    [ X.Mole.Grad = (X.Linear|Y.Linear|Z.Linear) ]

  Tertiary Compound Material
    X.Mole=<<num>> ( X.Mole.Slope=<<num>> | X.Mole.End=<<num>> )
    [ X.Mole.Grad = (X.Linear|Y.Linear|Z.Linear) ]
    Y.Mole=<<num>> ( Y.Mole.Slope=<<num>> | Y.Mole.End=<<num>> )
    [ X.Mole.Grad = (X.Linear|Y.Linear|Z.Linear) ]
\end{lstlisting}
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
\multicolumn{5}{l}{\textbf{General Parameters}}
\\
 $\mathbf{Region}$
& string
& Identifier of the compound material region.
\par
& none
& none
\\
 $\mathbf{x.min}$
& numerical
& Left boundary of the profile. Synonym: $\mathbf{x.left}$.
& 0.0
& $\uMeter$
\\
 $\mathbf{x.max}$
& numerical
& Right boundary of the profile. Synonym: $\mathbf{x.right}$.
& 0.0
& $\uMeter$
\\
 $\mathbf{y.min}$
& numerical
& Top boundary of the profile. Synonym: $\mathbf{y.top}$.
& 0.0
& $\uMeter$
\\
 $\mathbf{y.max}$
& numerical
& Bottom boundary of the profile. Synonym: $\mathbf{y.bottom}$.
& 0.0
& $\uMeter$
\\
 $\mathbf{z.min}$
& numerical
& Front boundary of the profile. Synonym: $\mathbf{z.front}$.
& 0.0
& $\uMeter$
\\
 $\mathbf{z.max}$
& numerical
& Back boundary of the profile. Synonym: $\mathbf{z.back}$.
& 0.0
& $\uMeter$\\
\multicolumn{5}{l}{\textbf{Binary Compound}}
\\
 $\mathbf{X.Mole}$
& numerical
& Starting mole fraction x of compound material A\low{x}B\low{1-x}.
& 0.0
& none
\\
 $\mathbf{X.Mole.Slope}$
& numerical
& The slope of mole fraction x.
& 0.0
& $\Inverse\uMeter$
\\
 $\mathbf{X.Mole.End}$
& numerical
& The mole fraction x at the end of the profile.
& 0.0
& none
\\
 $\mathbf{X.Mole.Grad}$
& enum
& The direction of mole fraction gradient.
& $\mathbf{Y.Linear}$
& none\\
\multicolumn{5}{l}{\textbf{Tertiary Compound}}
\\
 $\mathbf{X.Mole}$
& numerical
& Starting mole fraction x of compound material A\low{x}B\low{y}C\low{1-x-y}.
& 0.0
& none
\\
 $\mathbf{X.Mole.Slope}$
& numerical
& The slope of mole fraction x.
& 0.0
& $\Inverse\uMeter$
\\
 $\mathbf{X.Mole.End}$
& numerical
& The mole fraction x at the end of the profile.
& 0.0
& none
\\
 $\mathbf{X.Mole.Grad}$
& enum
& The direction of mole fraction gradient.
& $\mathbf{Y.Linear}$
& none
\\
 $\mathbf{Y.Mole}$
& numerical
& Starting mole fraction y.
& 0.0
& $\Inverse\uMeter$
\\
 $\mathbf{Y.Mole.Slope}$
& numerical
& The slope of mole fraction y.
& 0.0
& none
\\
 $\mathbf{Y.Mole.End}$
& numerical
& The mole fraction y at the end of the profile.
& 0.0
& none
\\
 $\mathbf{Y.Mole.Grad}$
& enum
& The direction of mole fraction gradient.
& $\mathbf{Y.Linear}$
& none\\
\end{longtable}

\par
\subsubsection{Description}
Only linear mole fraction profile with its gradient aligned with one of the three Cartesian axes is
          currently supported. There are two alternative ways to specify the expression of the profile. One can either
          specify the slope explicitly with $\mathbf{X.Mole.Slope}$
and the mole fraction at the starting
          end with $\mathbf{X.Mole}$. Starting end is defined as the one with smaller coordinate value in
          the direction of $\mathbf{X.Mole.Grad}$. Alternatively, one can set the mole fraction at both ends
          of the region with $\mathbf{X.Mole}$ and $\mathbf{X.Mole.End}$, and let GENIUS
          calculate the gradient.
\par
\subsubsection{Example}
\begin{lstlisting}[style=GeniusCode]
MOLE   region=SiGe X.Mole=0.4 X.Mole.End=0.7 \
       X.Mole.Grad=Y.Linear

MOLE   region=SiGe X.Mole=0.4 X.Mole.Slope=0.1 \
       Y.Min=0 Y.Max=0.3 X.Mole.Grad=Y.Linear
\end{lstlisting}
\section{Physical Models}
\subsection{PMI}
\index{PMI command}In Genius, the physical models of each material is loaded to the simulation system through the
        physical model interface (PMI). The models can be selected through the
$\mathbf{PMI}$ command. The model
        parameters are also specified here. The general syntax of the
$\mathbf{PMI}$ command is
\par
\begin{lstlisting}[style=GeniusCmd]
PMI
  REGION=str
  [ Type= (Basic|Band|Mobility|Impact|Thermal|Optical|Trap) ]
  [ Model=<<str>> ] [print=<<int>>]
  [ real<<<str>>>=<<num>> [ real<<<str>>>=<<num>> [...] ] ]
  [ string<<<str>>>=<<str>> [ string<<<str>>>=<<str>> [...] ] ]
\end{lstlisting}
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
\multicolumn{5}{l}{\textbf{Setup Loadable Physical Models}}
\\
 $\mathbf{Region}$
& string
& The region that the loaded model would apply to. A valid region name must be supplied,
                  otherwise the simulation will abort.
& none
& none
\\
 $\mathbf{Type}$
& enum
& The type of model to be loaded. Seven types are currently supported in
                  Genius, though some of them are not applicable to all material
                  regions.
\par
\begin{compactitem}
\item A $\mathbf{Basic}$ model specifies the basic physical parameters such as
                        permittivity and electron affinity, etc.
\par
\item A $\mathbf{Band}$ model specifies parameters related to the band structure of
                        semiconductors, which include energy bandgap, effective density of states, effective masses,
                        etc. It also calculates rates of some fundamental processes such as carrier recombination rates.
$\mathbf{Band}$ models are applicable to semiconductor regions only.
\par
\item A $\mathbf{Mobility}$ model calculates the mobility of carriers, taking into
                        consideration the effect of temperature, doping, electric field and adjacent interfaces, etc. A
                        range of mobility models are provided in Genius, which will be
                        discussed in more detail in \nameref{sec:CmdRef:PMI:Mobility},
p. \pageref{sec:CmdRef:PMI:Mobility}. Mobility models apply to
                        semiconductor regions only.
\par
\item An $\mathbf{Impact}$ model calculates the carrier generation rates due to the
                        impact ionization process. A later section will describe impact ionization models in detail.
$\mathbf{Impact}$ models apply to semiconductor regions only.
\par
\item An $\mathbf{Thermal}$ model describes the thermal conduction property of
                        materials.
\par
\item An $\mathbf{Optical}$ model describes the optical propagation property of
                        materials.
\par
\item An $\mathbf{Trap}$ model calculates the rate of carriers capture and emission
                        at traps. $\mathbf{Trap}$ models currently apply to semiconductor regions and
                        semiconductor/insulator interfaces.
\par
\end{compactitem}
& Mobility
& none
\\
 $\mathbf{Model}$
& string
& Name of the physical models to be loaded. The list of available models for each material and
                  each type of models is summarized in later sections.
& Default
& none
\\
 $\mathbf{Print}$
& integer
& If greater than 0, print the current values of all the material parameters.
& 0
& none
\\
 $\mathbf{real<str>}$
& numerical
& Additional custom numerical parameters accepted by the loaded model. The name of the parameter
                  is specified by $\mathbf{str}$.
& none
& unknown
\\
 $\mathbf{string<str>}$
& string
& Additional custom string parameters accepted by the loaded model. The name of the parameter is
                  specified by $\mathbf{str}$.
& none
& none\\
\end{longtable}

\subsubsection{Description}
The core program of Genius access the numerous material-specific models via the Physical Model Interface
          (PMI).
\par
In Genius, each supported material has a corresponding dynamic loadable library (DLL) file located in
          the  FilenameType \$(GENIU\_DIR)/lib/ directory. Each DLL file contains all models applicable to that
          material. For instance, all physical models for Si material are stored in
 FilenameType \$(GENIUS\_DIR)/lib/libSi.so.
\par
For each type of models, a default model will be loaded in the absence of a
$\mathbf{PMI}$ command. When the user supplied one or more $\mathbf{PMI}$
commands, Genius
          sequentially loads the specified model and assign it to the specified region. The user can optionally supply a
          list of custom numerical and string parameters to the PMI model. For instance, the following command loads the
          trap model for Silicon region, and setup the parameters of the trap model.
\begin{lstlisting}[style=GeniusCode]
PMI  Region=Silicon Type=Trap string<Type>=Bulk \
     string<Profile>=dopingA string<ChargeType>=Acceptor \
     double<Energy>=0.1
\end{lstlisting}
Each PMI model has its own list of accepted parameters, and the user should consult the
          description of the individual PMI models for details.
\par
If the model specified by a $\mathbf{PMI}$ command has already been loaded, the previously
          loaded one is \emph{not} replaced. The latter $\mathbf{PMI}$
command are useful in
          adjusting the custom parameters of the PMI model.
\par
\marginhead{Custom PMI Model}Advanced users of Genius can compile and produce dynamic libraries that
            contain custom PMI models. The easiest way of writing custom PMI model is to extend from the source code of
            existing models. See [[TODO]] for a tutorial guide and detailed references.
\par
\par
\subsubsection{Mobility Models}
\label{sec:CmdRef:PMI:Mobility}
The mobility model can be selected in the $\mathbf{Model}$ parameter of the PMI
          command:
\par
\begin{lstlisting}[style=GeniusCmd]
PMI
    REGION=<<str>> Type=Trap [ Model=<<str>> ]
    [ <<param>>=<<val>> [ <<param>>=<<val>> [ ... ] ] ]
  %
\end{lstlisting}
The variety of available mobility models and the default model for each material is summarized in
\tabref{tab:CmdRef:PMI:Mobility:Summary}, p. \pageref{tab:CmdRef:PMI:Mobility:Summary}. Each model has a set of its own parameters, which can be
          adjusted with the PMI command. The description of each mobility model and the corresponding parameters are
          detailed in \nameref{sec:Equation:Mobility}, p. \pageref{sec:Equation:Mobility}.
\par
\begin{longtable}{lll}
\caption{\label{tab:CmdRef:PMI:Mobility:Summary}Summary of Available PMI Mobility Models}\\
\hline
 Material
& Models
& Default\\
\hline
 3C-SiC
& $\mathbf{Analytic}$
& $\mathbf{Analytic}$
\\
 4H-SiC
& $\mathbf{Masetti}$
& $\mathbf{Masetti}$
\\
 AlGaAs
& $\mathbf{Analytic}$
& $\mathbf{Analytic}$
\\
 GaAs
& $\mathbf{Analytic}$, $\mathbf{Hypertang}$
& $\mathbf{Analytic}$
\\
 Ge
& $\mathbf{Analytic}$
& $\mathbf{Analytic}$
\\
 HgCdTe
& $\mathbf{Analytic}$
& $\mathbf{Analytic}$
\\
 InAs
& $\mathbf{Analytic}$
& $\mathbf{Analytic}$
\\
 InGaAs
& $\mathbf{Analytic}$
& $\mathbf{Analytic}$
\\
 InN
& $\mathbf{Analytic}$
& $\mathbf{Analytic}$
\\
 InP
& $\mathbf{Analytic}$
& $\mathbf{Analytic}$
\\
 InSb
& $\mathbf{Analytic}$
& $\mathbf{Analytic}$
\\
 S-SiO2
& $\mathbf{Constant}$
& $\mathbf{Constant}$
\\
 Si
& $\mathbf{Constant}$, $\mathbf{Analytic}$, $\mathbf{Philips}$, $\mathbf{HP}$,
$\mathbf{Lucent}$, $\mathbf{Lombardi}$
& $\mathbf{Analytic}$
\\
 SiGe
& $\mathbf{Constant}$, $\mathbf{Analytic}$, $\mathbf{Philips}$, $\mathbf{HP}$,
$\mathbf{Lucent}$, $\mathbf{Lombardi}$
& $\mathbf{Analytic}$\\
\end{longtable}
The following example shows how one can load the HP mobility model and adjust the default
          parameter.
\par
\begin{lstlisting}[style=GeniusCode]
PMI  Region=Silicon Type=Mobility Model=HP \
     double<MUN.MAX>=1200 double<MUP.MAX>=400
\end{lstlisting}
\subsubsection{Impact Ionization Models}
The mobility model can be selected in the $\mathbf{Model}$ parameter of the PMI
          command:
\par
\begin{lstlisting}[style=GeniusCmd]
PMI
  REGION=<<str>> Type=Impact [ Model=<<str>> ]
  [ <<param>>=<<val>> [ <<param>>=<<val>> [ ... ] ] ]
\end{lstlisting}
For silicon and many other materials, the $\mathbf{Default}$ avalanche generation model is
          the Selberherr model. The models for various materials are summarized in
\tabref{tab:CmdRef:PMI:Avalanche:Summary}, p. \pageref{tab:CmdRef:PMI:Avalanche:Summary}.
\par
\begin{longtable}{lll}
\caption{\label{tab:CmdRef:PMI:Avalanche:Summary}Summary of Available PMI Impact Ionization Models}\\
\hline
 Material
& Models
& Default\\
\hline
3C-SiC
& $\mathbf{Selberherr}$
& $\mathbf{Selberherr}$
\\
 4H-SiC
& $\mathbf{vanOverstraetendeMan}$
& $\mathbf{vanOverstraetendeMan}$
\\
 AlGaAs
& $\mathbf{Selberherr}$
& $\mathbf{Selberherr}$
\\
 GaAs
& $\mathbf{Selberherr}$
& $\mathbf{Selberherr}$
\\
 Ge
& $\mathbf{Selberherr}$
& $\mathbf{Selberherr}$
\\
 HgCdTe
& -
& -
\\
 InAs
& $\mathbf{vanOverstraetendeMan}$
& $\mathbf{vanOverstraetendeMan}$
\\
 InGaAs
& $\mathbf{Selberherr}$
& -
\\
 InN
& $\mathbf{vanOverstraetendeMan}$
& $\mathbf{vanOverstraetendeMan}$
\\
 InP
& $\mathbf{Selberherr}$
& $\mathbf{Selberherr}$
\\
 InSb
& $\mathbf{vanOverstraetendeMan}$
& $\mathbf{vanOverstraetendeMan}$
\\
 S-SiO2
& -
& -
\\
 Si
& $\mathbf{Selberherr}$, $\mathbf{Valdinoci}$
& $\mathbf{Selberherr}$
\\
 SiGe
& $\mathbf{Selberherr}$
& $\mathbf{Selberherr}$\\
\end{longtable}

\par
\subsubsection{Trap Model}
Although the charge trapping model is automatically loaded, the user needs to setup trap parameters with
$\mathbf{PMI}$ command for it effect. The syntax and parameters are as follows.
\par
\begin{lstlisting}[style=GeniusCmd]
PMI
    REGION=<<str>> Type=Trap Model=Default
    [string<Type> = (Bulk|Interface)]
    [string<ChargeType> = (Acceptor|Donor)]
    [real<Energy>=<<num>>] [real<SigmaN>=<<num>>] [real<SigmaP>=<<num>>]

  Bulk Trap
    { string<Profile>=<<str>> [ real<Prefactor>=<<num>> ]  |

  Interface Trap
    string<Interface>=<<str>> real<IF.Density>=<<num>> }
\end{lstlisting}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
\multicolumn{5}{l}{\textbf{Common Trap Parameters}}
\\
 $\mathbf{Type}$
& enum
& Selects whether the current command specifies $\mathbf{Bulk}$
or $\mathbf{Interface}$ traps.
& $\mathbf{Bulk}$
& none
\\
 $\mathbf{ChargeType}$
& enum
& Selects whether the traps is $\mathbf{Acceptor}$ or $\mathbf{Donor}$.
& $\mathbf{Acceptor}$
& none
\\
 $\mathbf{Energy}$
& numerical
& Energy of the trap level relative to the intrinsic Fermi level of the material.
& 0
& $\eVolt$
\\
 $\mathbf{SigmaN}$
& numerical
& Capture cross-section for electrons.
& 4e16
& $cm^{-2}$
\\
 $\mathbf{SigmaP}$
& numerical
& Capture cross-section for holes.
& 4e16
& $cm^{-2}$\\
\multicolumn{5}{l}{\textbf{Bulk Trap Parameters}}
\\
 $\mathbf{Profile}$
& string
& The concentration of bulk traps is derived from a custom doping profile defined by a
$\mathbf{PROFILE}$ command. ID of the custom profile should be specified here.
& none
& none
\\
 $\mathbf{Prefactor}$
& numerical
& The concentration of the doping profile specified by $\mathbf{Profile}$
is scaled
                  by this $\mathbf{Prefactor}$. This is useful in generating a number of traps with the same
                  spatial distribution but different trap energies.
& 1.0
& none\\
\multicolumn{5}{l}{\textbf{Interface Trap Parameters}}
\\
 $\mathbf{Interface}$
& string
& Interface traps are attached to the insulator/semiconductor interface with the ID specified
                  here. When an semiconductor region and an insulator region share a common face, an interface is
                  automatically generated. The ID of the interface is in the format of
$\mathbf{RegionName1_to_RegionName2}$. Alternatively, one can use a
$\mathbf{Face}$ command to define an interface with a user-specified ID.
& none
& none
\\
 $\mathbf{IF.Density}$
& numerical
& The interface density of traps.
& 0.0
& $cm^{-2}$\\
\end{longtable}

\subsubsection{Incomplete Ionization Model}
User can setup incomplete ionization parameters with $\mathbf{PMI}$
command. Please note, for
          active this model, use also have to set $\mathbf{IncompleteIonization}$
to true in the $\mathbf{MODEL}$ statement. Also, it is recommend to use Fermi statistics with IncompleteIonization.
          The syntax and parameters are as follows.
\par
\begin{lstlisting}[style=GeniusCmd]
PMI
    REGION=<<str>> Type=band
    [string<species>=<<str>>] [int<ion>=(+1|-1)]
    [real<EB0>=<<num>>] [real<GB>=<<num>>]
    [real<alpha>=<<num>>] [real<beta>=<<num>>] [real<gamma>=<<num>>]
  %
\end{lstlisting}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
\multicolumn{5}{l}{\textbf{Common Trap Parameters}}
\\
 $\mathbf{species}$
& string
& Specify profile species. The string parameter is the id of profile with Custom ion
                    type.
& $\mathbf{none}$
& none
\\
 $\mathbf{ion}$
& integer
& Selects whether the species is $\mathbf{Acceptor}$(-1) or $\mathbf{Donor(+1)}$.
& $\mathbf{0}$
& none
\\
 $\mathbf{EB0}$
& numerical
& The constant activation energy.
& 0
& $\eVolt$
\\
 $\mathbf{GB}$
& numerical
& The band degeneracy factor
& none
& none
\\
 $\mathbf{alpha}$
& numerical
& The prefactor for the doping dependent term used in the calculation of the band ionization
                    energy.
& none
& $\eVolt\Inverse\cMeter$
\\
 $\mathbf{beta}$
& numerical
& The prefactor the temperature dependent term used in the calculation of the band ionization
                    energy.
& none
& none
\\
 $\mathbf{gamma}$
& numerical
& The exponent of temperature used in the calculation of the band ionization energy.
& none
& none\\
\end{longtable}

\par
\subsection{MODEL}
\index{MODEL command}The MODEL command sets the switches that controls the behavior of the physical equations.
\par
\begin{lstlisting}[style=GeniusCmd]
MODEL
  Region=str
  [ Fermi=bool ] [IncompleteIonization=bool]
  { H.Mob=bool [ Mob.Force = (EJ|ESimple|EQF) ] }
  { ImpactIonization = (Local|No)
    [ II.Force = (EdotJ|ESide|EVector|GradQF) ] }
  [ BBT = (Local|No) ]
  [ Optical.Gen = (true|false) ]
  [ Particle.Gen = (true|false) ]
  [ EB.Level= (None|Tl|Te|Th|TeTh|TeTl|ThTl|ALL) ]
\end{lstlisting}
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
 $\mathbf{Region}$
& string
& Select models in the specified region.
& $\mathbf{none}$
& none
\\
 $\mathbf{Fermi}$
& boolean
& Turns on Fermi-Dirac carrier statistics.
& $\mathbf{false}$
& none\\
\multicolumn{5}{l}{\textbf{IncompleteIonization}}
\\
 $\mathbf{H.Mob}$
& boolean
& Synonym to $\mathbf{HighFieldMobility}$. Activate high-field mobility calculation.
                  When $\mathbf{H.Mob}$ is true, parallel and transverse fields are calculated and passed to
                  the mobility model, so that high-field effects on carrier mobility are taken into account.
& $\mathbf{true}$
& none
\\
 $\mathbf{ESurface}$
& boolean
& Use effective surface electric field for carrier mobility calculation at
                  insulator-semiconductor interface.
& $\mathbf{true}$
& none
\\
 $\mathbf{Mob.Force}$
& enum
& Synonym to $\mathbf{Mobility.Force}$. When $\mathbf{H.Mob}$ is
                  enabled, this parameter selects the driving field used in high-field mobility
                  calculation.
\begin{compactitem}
\item When $\mathbf{EJ}$ is selected, the dot product between electric field and
                        current density ($\vec{E}\cdot\vec{J}/\vert\vec{J}\vert$) is used as
                        the parallel field. The cross product ($\vec{E}\times\vec{J}/\vert\vec{J}\vert$) is used as the transverse
                        field.
\par
\item When $\mathbf{ESimple}$ is selected, the electric field $\vec{E}$
as the parallel field.
\par
\item When $\mathbf{EQF}$ is selected, the gradient of the quasi-fermi level
                        ($\nabla\phi_n$ and $\nabla\phi_p$) as
                        the parallel field. The transverse field is calculated with
$\vec{E}\times\vec{J}/\vert\vec{J}\vert$, as in $\mathbf{EJ}$ method.
\par
\end{compactitem}
\par
& $\mathbf{ESimple}$
& none
\\
 $\mathbf{ImpactIonization}$
& enum
& Activates the impact ionization (II) generation, and selects whether the II generation should
                  be calculated with the local model or the non-local model. Only the local model is currently
                  implemented.
& No
& none
\\
 $\mathbf{II.Force}$
& enum
& When $\mathbf{ImpactIonization}$ is enabled, this parameter selects the driving
                  field used in impact ionization coefficient calculation.
\begin{compactitem}
\item When $\mathbf{EdotJ}$ is selected, the dot product between electric field and
                        current density ($\vec{E}\cdot\vec{J}/\vert\vec{J}\vert$) is used as
                        the driving field.
\par
\item When $\mathbf{EVector}$ is selected, the magnitude of the electric field
$\vec{E}$ is used as the driving field.
\par
\item When $\mathbf{ESide}$ is selected, the E-field component along the edge of the
                        mesh element is used as the driving field.
\par
\item When $\mathbf{GradQf}$ is selected, the gradient of the quasi-fermi level
                        ($\nabla\phi_n$ and $\nabla\phi_p$) as
                        the driving field.
\par
\end{compactitem}
& No
& none
\\
 $\mathbf{BBT}$
& enum
& Activates the Band-to-Band Tunneling (BBT) generation, and selects whether the BBT generation
                  should be calculated with the local model or the non-local model. Only the local model is currently
                  implemented.
& No
& none
\\
 $\mathbf{EB.Level}$
& enum
& When the Energy-Balance equation solver is selected in the $\mathbf{METHOD}$
command,
                  this parameter selectively enables the equations for lattice temperature, electron temperature and
                  hole temperature.
& None
& none\\
\end{longtable}

\subsubsection{Example}
\begin{lstlisting}[style=GeniusCode]
MODEL  Region=emitter Fermi=true
MODEL  Region=silicon H.Mob=true Mob.Force=EQF
MODEL  Region=silicon EB.Level=TeTl
\end{lstlisting}
\section{Numerical Solution}
\par
\subsection{METHOD}
\index{METHOD command}The $\mathbf{METHOD}$
command specifies the parameters of the numerical solvers.
\par
\begin{lstlisting}[style=GeniusCmd]
METHOD

  Equation Selection
    [ Type = (Poisson|DDML1|DDML1Mix|DDML2|DDML2Mix|
              EBML3|EBML3Mix|HalfImplicit|Stress) ]

  Numeric Solver Selection
    [ NS = (Newton|LineSearch|TrustRegion) ]
    [ LS = (CGS|BICG|BCGS|GMRES|TFQMR|LU|UMFPACK|SuperLU|
            MUMPS|SuperLU_Dist) ]
    [ PC = (Identity|Jacobian|BJacobian|ASM|ILU) ]
    [ Damping = (No|Potential|BankRose) ]
    [ Truncation = (Always|Boundary|No) ]
    [ Halfimplicit.let = num ]

  Convergence Criteria
    [ MaxIteration=int ]
    [ Relative.Tol=num ] [ Poisson.Tol=num ]
    [ Elec.Continuity.Tol=num ] [ Hole.Continuity.Tol=num ]
    [ Elec.Energy.Tol=num ] [ Hole.Energy.Tol=num ]
    [ Latt.Temp.Tol=num ] [Electrode.Tol=num]
    [ Toler.Relax=num ] [ QNFactor=num ] [ QPFactor=num ]
\end{lstlisting}
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
\multicolumn{5}{l}{\textbf{Equation Selection}}
\\
 $\mathbf{Type}$
& enum
& Selects the set of partial differential equations to be solved.
\par
\begin{compactitem}
\item $\mathbf{Poisson}$ selects the Poisson's equation solver.
\par
\item $\mathbf{DDML1}$ selects the basic level-one drift-diffusion equation
                        solver.
\par
\item $\mathbf{DDML1Mix}$ selects the device-circuit mixed-mode solver with the
                        level-one drift-diffusion equation solver.
\par
\item $\mathbf{DDML2}$ selects the level-two drift-diffusion equation solver, which
                        includes the lattice temperature variation in device.
\par
\item $\mathbf{DDML2Mix}$ selects the device-circuit mixed-mode solver with the
                        level-two drift-diffusion equation solver.
\par
\item $\mathbf{EBML3}$ selects the energy-balance equation solver which includes
                        carrier temperature variation in device. Users can selectively activate the equations for
                        electron temperature, hole temperature and lattice temperature with the
$\mathbf{EB.Level}$ parameter in the $\mathbf{MODEL}$ command.
\par
\item $\mathbf{EBML3Mix}$ selects the device-circuit mixed-mode solver with the
                        energy-balance equation solver.
\par
\item $\mathbf{HalfImplicit}$ selects the fast half implicit solver. This solver
                        only support transient and OP simulation. And it runs typically 5x faster than DDM
                        solver.
\par
\item $\mathbf{Stress}$ selects the mechanical stress solver.
\par
\end{compactitem}
\par
& $\mathbf{DDML1}$
& none\\
\multicolumn{5}{l}{\textbf{Numerical Solver Selection}}
\\
 $\mathbf{NS}$
& enum
& Selects the Newton nonlinear solver algorithm.
\par
\begin{compactitem}
\item $\mathbf{Newton}$ (synonym: $\mathbf{Basic}$) selects the basic
                        nonlinear update algorithm with full Newton steps.
\par
\item $\mathbf{LineSearch}$ selects the cubic line-search update algorithm.
\par
\item $\mathbf{TrustRegion}$ selects the trust-region update algorithm.
\par
\end{compactitem}
& $\mathbf{LineSearch}$
& none
\\
 $\mathbf{LS}$
& enum
& Selects the linear solver algorithm.
& $\mathbf{BCGS}$
& none
\\
 $\mathbf{PC}$
& enum
& Selects the linear preconditioner algorithm.
& $\mathbf{ILU}$
& none
\\
 $\mathbf{Damping}$
& enum
& Selects the nonlinear update damping scheme.
& $\mathbf{Potential}$
& none
\\
 $\mathbf{Truncation}$
& enum
& Selects the element truncation strategy used in simulation.
& $\mathbf{Always}$
& none
\\
 Halfimplicit.let
& numerical
& Linearize error threshold of half implicit method. A larger threshold will speedup the
                  simulation, but introduce more error.
& 1.0
& Vt\\
\multicolumn{5}{l}{\textbf{Convergence Criteria of Nonlinear Solver}}
\\
 $\mathbf{MaxIteration}$
& integer
& Sets the number of maximum nonlinear iterations before the solver reports failure.
& 30
& none
\\
 $\mathbf{Relative.Tol}$
& numerical
& Sets the relative update tolerance.
& 1e-5
& none
\\
 $\mathbf{Poisson.Tol}$
& numerical
& Sets the absolute tolerance for the residue norm of Poisson's equation.
& 1e-26
& none
\\
 $\mathbf{Elec.C.Tol}$
& numerical
& Sets the absolute tolerance for the residue norm of the electron continuity equation. Synonym:
$\mathbf{Elec.Continuity.Tol}$.
& 5e-18
& none
\\
 $\mathbf{Hole.C.Tol}$
& numerical
& Sets the absolute tolerance for the residue norm of the hole continuity equation. Synonym:
$\mathbf{Hole.Continuity.Tol}$.
& 5e-18
& none
\\
 $\mathbf{Elec.E.Tol}$
& numerical
& Sets the absolute tolerance for the residue norm of the electron-energy balance equation. Only
                  applicable when the EBM solver is used and the electron energy-balance equation is activated. Synonym:
$\mathbf{Elec.Energy.Tol}$.
& 1e-18
& none
\\
 $\mathbf{Hole.E.Tol}$
& numerical
& Sets the absolute tolerance for the residue norm of the hole energy balance equation. Only
                  applicable when the EBM solver is used and the hole energy-balance equation is activated. Synonym:
$\mathbf{Hole.Energy.Tol}$.
& 1e-18
& none
\\
 $\mathbf{Latt.Temp.Tol}$
& numerical
& Sets the absolute tolerance for the residue norm of the lattice heat equation. Applicable when
                  the DDML2 solver is selected; or when the EBM solver is used and the lattice heat equation is
                  activated.
& 1e-11
& none
\\
 $\mathbf{Electrode.Tol}$
& numerical
& Sets the absolute tolerance for the residue norm of at the electrode boundaries.
& 1e-9
& none
\\
 $\mathbf{Toler.Relax}$
& numerical
& Sets the tolerance relaxation factor for convergence on relative tolerance criteria. When the
                  relative error is below $\mathbf{Relative.Tol}$, the solver checks the absolute residue
                  norms of all equations before it reports relative convergence. The absolute residue norms must be
                  below $\mathbf{Toler.Relax}$*$\mathbf{aTol}$, where aTol is the various
                  absolute tolerance described above.
& 1e4
& none\\
\multicolumn{5}{l}{\textbf{Convergence Criteria of Linear Solver}}
\\
 $\mathbf{KSP.RTol}$
& numerical
& Relative tolerance of convergence criterion when ksp methods are usedrelative tolerance of
                  convergence criterion when ksp methods are used.
& 1e-8
& none
\\
 $\mathbf{KSP.ATol}$
& numerical
& Absolute tolerance of convergence criterion when ksp methods are used.
& 1e-20
& none
\\
 $\mathbf{KSP.ATol.FNorm}$
& numerical
& Absolute tolerance convergence criterion, when the residue norm of ksp iteration less than
${\bf ksp.atol.fnorm*}\left\Vert {\bf F}({\bf x}) \right\Vert$.
& 1e-7
& none\\
\end{longtable}

\subsubsection{Nonlinear Solver Algorithms}
GENIUS solves the coupled Poisson-Drift-Diffusion equations in semiconductor devices with Newton's
          method. The system of nonlinear equations is written as
${\bf F}({\bf x})=0$,
          where ${\bf F}$ is the nonlinear function and ${\bf
          x}$ is the solution. Starting from an initial guess to the solution, one can solve the nonlinear
          equation iteratively. The update to the solution in every iteration is computed from the following linear
          system of equations,
\par
\begin{equation}
\label{eq:CmdRef:Method:Nonlinear:Eqn}
{\bf J}\left({\bf x}\right) \cdot {\bf p} = - {\bf F} \left({\bf x}\right)
\end{equation}
where ${\bf p}$ is the computed update, and ${\bf
          J}$ is the Jacobian of ${\bf F}$. In the basic Newton algorithm, the new
          solution ${\bf x}^{\prime}$ is
\begin{equation}
{\bf x}^{\prime} = {\bf x} + {\bf p}.
\end{equation}
\par
\par
This iterative process continues until the convergence criteria is met. Apart from the basic algorithm
          described above, two variants of Newton solution update algorithms are provided. The cubic linesearch
          algorithm and the Trust-Region update algorithms can be selected with the
$\mathbf{NS}$ parameter.
\par
Update damping algorithms can be used with Newton methods to improve stability of the iterative process.
          All updates are damped so that the carrier densities are positive. When the
$\mathbf{Basic}$ Newton algorithm is selected, one can turn on the Potential damping or the Bank-Rose damping, which sometimes
          improve convergence.
\par
\subsubsection{Nonlinear Convergence Criteria}
The nonlinear solver checks for convergence after Newton iteration. The following sets of criteria are
          checked in sequence, if any one set of criteria is met, the solution is determined to have reached
          convergence.
\par
\marginhead{Absolute Residue Norm Convergence}The residue of each device equation is evaluated. If the norm of each residue is less than the
            respective absolute tolerance, convergence is reached.
\par
\par
\marginhead{Relative Residue Norm Convergence}The residue of all device equations is evaluated, and its norm compared against the residue norm
            before the nonlinear iterations. If the ratio between the two norm is less than the relative tolerance, the
            absolute residue norm criteria is further checked with the absolute tolerance relaxed by the factor
$\mathbf{Toler.Relax}$. Convergence is reached if both tests passes.
\par
\par
\marginhead{Relative Update Norm Convergence}The norm of the update in the Newton iteration is evaluated, if this norm is less than the relative
            tolerance, the absolute residue norm criteria is further checked with the absolute tolerance relaxed by the
            factor $\mathbf{Toler.Relax}$. Convergence is reached if both tests passes.
\par
\par
\subsubsection{Linear Solver Algorithms}
\eqref{eq:CmdRef:Method:Nonlinear:Eqn}, p. \pageref{eq:CmdRef:Method:Nonlinear:Eqn}
can be solved by direct method based on LU
          factorization. Direct linear solvers usually gives the exact solution of
\eqref{eq:CmdRef:Method:Nonlinear:Eqn}. A few direct linear solvers based on LU
          decomposition are also provided. The default $\mathbf{LU}$
solver only supports serial execution.
          The UMFPACK solver is a fast serial direct solver, while MUMPS supports parallel computation. The serial and
          parallel version of SuperLU are also available.
\par
Alternatively, the more efficient iterative methods based on Krylov subspace (KSP) theory can be used.
          However, iterative methods can only give approximate results. Among the choices of linear system solvers, the
$\mathbf{CG}$, $\mathbf{BCGS}$, $\mathbf{GMRES}$ methods are KSP iterative
          solvers. A preconditioner is necessary for effective operation of iterative solvers. The
$\mathbf{ILU}$ algorithm usually provides good performance. All the iterative solver and
          preconditioners listed here support parallel computation. The KSP iteration stops when any of the two criteria
          is met:
\par
\begin{compactitem}
\item the NORM change between two iteration less than ksp.rtol.
\par
\item residue NORM less than $\max\left({\bf ksp.atol.fnorm*}( \left\Vert {\bf F}({\bf
              x}) \right\Vert),{\bf ksp.atol} \right)$.
\par
\end{compactitem}
The iterative linear solver may fail to reach convergence in some cases, which cause the nonlinear
          solver fail with the error $\mathbf{DIVERGED_LINEAR_SOLVER}$. In this case one may try relaxing
          the three linear solver tolerance parameters. On the other hand, if the error norm of the nonlinear solver
          stagnates when a KSP linear solver is in use, it may be caused by inexact linear solution. Tightening the KSP
          convergence criteria may help.
\par
\subsection{SOLVE}
\index{SOLVE command}The $\mathbf{SOLVE}$
command instructs Genius to solve the semiconductor device
        equations.
\par
\begin{lstlisting}[style=GeniusCmd]
SOLVE
  [Type=(Equilibrium|SteadyState|DCSweep|Op|ACSweep|Transient)]
  [Predict=bool]

  DCSweep Simulation Parameters
    { VScan=str VStart=num VStep=num VStop=num
      [ VStepMax=num ] } |
    { IScan=str IStart=num IStep=num IStop=num
      [ IStepMax=num ] }
    [ Optical.Gen=bool ] [ Optical.modulate=str ]
    [ Particle.Gen=bool ]

  Operator Point Parameters for Mixed-type Simulation
    { [ rampup.steps=int ] [ rampup.vstep=num ]
      [ rampup.istep=num ]
      [ gmin=num ] [ gmin.init=num ]
    }

  Operator Point Parameters for Device Simulation
    { [ pseudotime=bool ] [ pseudotime.step=num ]
      [ pseudotime.iteration=int ]
      [ VStepMax=num ] [ IStepMax=num ]
    }

  Transient Simulation Parameters
    { TS=(ImplicitEuler|BDF1|BDF2|TRBDF2)
      TStart=num TStep=num TStop=num
      [ AutoStep=bool ] [ TStepMax=num ]
      [ TS.rTol=num ]   [ TS.aTol=num ]
      [ VStepMax=num ]  [ IStepMax=num ]
      [ Optical.Gen=bool ] [ Optical.modulate=str ]
      [ Particle.Gen=bool ] [Source.coupled=bool]
      [ tranop=bool ]
    }

  ACSweep Simulation Parameters
    { VScan=str f.start=num f.stop=num
      [ f.multiple=num ]
      [ vac=num ]
    }


  Input/Output Parameters
    [ Hook=str ] [ Out.Prefix=str ]
\end{lstlisting}
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
\multicolumn{5}{l}{\textbf{General Parameters}}
\\
 $\mathbf{Type}$
& enum
& Selects the mode of the simulation.
\par
\begin{compactitem}
\item $\mathbf{Equilibrium}$ sets all external sources to zero, and timestep to
                        infinity, so that the device equations yield equlibrium-state solution.
\par
\item $\mathbf{SteadyState}$ sets all external sources to their respective value at
                        time zero, and timestep to infinity.
\par
\item $\mathbf{DCSweep}$ scans the external voltage (or current) source at one of
                        the contacts. At each voltage (or current) step, the device equations are solved in
                        steadystate.
\par
\item $\mathbf{OP}$ solves the operator point of device or circuit at time zero,
                        some convergence acceleration techniques such as gmin step in circuit simulation and pseudo time
                        method for device can be used.
\par
\item $\mathbf{ACSweep}$ applies an small-signal stimulus at one of the contacts,
                        and scans the frequency of the signal.
\par
\item $\mathbf{Transient}$ solves the device equation with physical quantities in
                        the device and external sources vary as time progresses.
\par
\end{compactitem}
\par
& $\mathbf{Equilibrium}$
& none
\\
 $\mathbf{Predict}$
& bool
& When $\mathbf{Predict}$ is enabled, the solver use predictions based on
                  previous solutions as the initial guess to the new solution. When three previous solutions are
                  available, quadratic projection is used. When there are two previous solutions, linear projection is
                  used.
\par
When $\mathbf{Predict}$ is disabled, the solver uses the previous
                  solution as the initial guess.
\par
$\mathbf{Predict}$ is applicable to DC-sweep
                  and transient modes only.
\par
& true
& none
\\
 $\mathbf{Optical.Gen}$
& boolean
& Consider optical carrier generation in the simulation. Applicable in DC- and transient-mode
                  simulations only.
& false
& none
\\
 $\mathbf{Optical.modulate}$
& string
& Optical wave can be modulated by an envelope, which is specified by
$\mathbf{ENVELOP}$ statement. When this parameter is omitted, constant envelop with amplitude 1.0 will be used. For DC
                  simulation, value at transient time 0 will be used.
& none
& none
\\
 $\mathbf{Particle.Gen}$
& boolean
& Consider carriers generated by high-energy particles in the simulation. Applicable in DC- and
                  transient-mode simulations only.
& false
& none
\\
 Source.coupled
& boolean
& Indicate that the light absorption or particle generation is coupled with semiconductor device.
                  Thus, Genius will re-calculate carrier generation on each device state.
& false
& none\\
\multicolumn{5}{l}{\textbf{DC Sweep Simulation Parameters}}
\\
 $\mathbf{VScan}$
& string
& The electrode on which voltage sweep is applied.
& none
& none
\\
 $\mathbf{VStart}$
& numerical
& Start voltage.
& none
& $\Volt$
\\
 $\mathbf{VStep}$
& numerical
& Initial voltage step. The actual voltage steps may change when there is convergence
                  problem.
& none
& $\Volt$
\\
 $\mathbf{VStop}$
& numerical
& Stop voltage.
& none
& $\Volt$
\\
 $\mathbf{VStepMax}$
& numerical
& Maximum voltage step.
& $\mathbf{VStep}$
& $\Volt$
\\
 $\mathbf{IScan}$
& string
& The electrode on which current sweep is applied.
& none
& none
\\
 $\mathbf{IStart}$
& numerical
& Start current.
& none
& $\Ampere$
\\
 $\mathbf{IStep}$
& numerical
& Initial current step. The actual current steps may change when there is convergence
                  problem.
& none
& $\Ampere$
\\
 $\mathbf{IStop}$
& numerical
& Stop current.
& none
& $\Ampere$
\\
 $\mathbf{IStepMax}$
& numerical
& Maximum current step.
& $\mathbf{IStep}$
& $\Ampere$\\
\multicolumn{5}{l}{\textbf{Circuit Operation-Point Simulation Parameters for Mixed Simulation}}
\\
 $\mathbf{rampup.steps}$
& integer
& The number of ramp-up steps for the voltage and current sources in the circuit to their DC
                  value.
& 1
& none
\\
 $\mathbf{rampup.vstep}$
& numerical
& The maximum changes of voltage in any ramp up step.
& 0.25
& $\Volt$
\\
 $\mathbf{rampup.istep}$
& numerical
& The maximum changes of current in any ramp up step.
& 0.1
& $\Ampere$
\\
 $\mathbf{gmin.init}$
& numerical
& The initial value of gmin in gmin step-down. A large value may help convergence for difficult
                  circuits.
& 1e-12
& $\Inverse\Ohm$
\\
 $\mathbf{gmin}$
& numerical
& The target value of gmin step-down. This value should be sufficiently samll to avoid error in
                  circuit simulation.
& 1e-12
& $\Inverse\Ohm$\\
\multicolumn{5}{l}{\textbf{Pseudo-Time DC Simulation Parameters}}
\\
 $\mathbf{pseudotime}$
& bool
& When $\mathbf{pseudotime}$ is set to true, Genius will use pseudo-time method to
                  calculate the steady-state solution of the device. Currently available in pure device simulation, with
$\mathbf{type=OP}$.
& $\mathbf{false}$
& none
\\
 $\mathbf{pseudotime.step}$
& numerical
& Time step for the pseudo-time method. Small time step will make the system more stable but
                  require more time steps to drive the system to steady state.
& $\mathbf{1e-6}$
& $\Second$
\\
 $\mathbf{pseudotime.iter}$
& numerical
& Maximum number of pseudo-time iteration steps for driving the system to steady state.
& $\mathbf{20}$
& none
\\
 $\mathbf{VStepMax}$
& numerical
& Maximum voltage update in any pseudo-time step.
& $\mathbf{0.1}$
& $\Volt$
\\
 $\mathbf{IStepMax}$
& numerical
& Maximum current update in any pseudo-time step.
& $\mathbf{0.1}$
& $\Ampere$\\
\multicolumn{5}{l}{\textbf{Transient Simulation Parameters}}
\\
 $\mathbf{TS}$
& Enum
& Sets the time-discretization scheme. Available choices are BDF1 (aka. Implicit Euler), BDF2 and
                  TRBDF2.
& $\mathbf{BDF2}$
& none
\\
 $\mathbf{TStart}$
& numerical
& Initial time.
& 0.0
& $\Second$
\\
 $\mathbf{TStep}$
& numerical
& Initial time step. The actual time steps is adaptively determined by the solver if
$\mathbf{AutoStep}$ is enabled.
& none
& $\Second$
\\
 $\mathbf{TStop}$
& numerical
& Stop time.
& none
& $\Second$
\\
 $\mathbf{TStepMax}$
& numerical
& The maximum allowed time step when the solver automatically determines time steps. If
$\mathbf{TStepMax}$ is zero, there is no upper bound for time steps.
& 0.0
& $\Second$
\\
 $\mathbf{AutoStep}$
& bool
& Sets if the solver can adaptively change the time steps.
& true
& none
\\
 $\mathbf{TS.rTol}$
& numerical
& Sets the relative truncation error tolerance in time-discretization. When the tolerance
                  criteria is not met, the current time step is rejected, and time step is reduced.
& 1e-3
& none
\\
 $\mathbf{TS.aTol}$
& numerical
& Sets the absolute truncation error tolerance in time-discretization. When the tolerance
                  criteria is not met, the current time step is rejected, and time step is reduced.
& 1e-4
& none
\\
 $\mathbf{VStepMax}$
& numerical
& Limit the time step so the maxim change of electrode voltage is less than this value
& 1.0
& $\Volt$
\\
 $\mathbf{IStepMax}$
& numerical
& Limit the time step so the maxim change of electrode current is less than this value
& 1.0
& $\Ampere$
\\
 $\mathbf{tranop}$
& bool
& Sets if operator point should be computed before transient simulation start. Only valid in
                  Mixed-type Simulation. This option shoule be set to false when
$\mathbf{OP}$ already
                  calculated.
& true
& none\\
\multicolumn{5}{l}{\textbf{AC Sweep Simulation}}
\\
 $\mathbf{VScan}$
& string
& The electrode on which small AC signal is applied.
& none
& none
\\
 $\mathbf{f.start}$
& numerical
& Start frequency for AC sweep
& 1e6
& $\Hertz$
\\
 $\mathbf{f.stop}$
& numerical
& Stop frequency for AC sweep.
& 10e9
& $\Hertz$
\\
 $\mathbf{f.multiple}$
& numerical
& Specifies multiplicative factor for incrementing frequency.
& 1.1
& none
\\
 $\mathbf{vac}$
& numerical
& The magnitude of AC signal.
& 0.0026
& $\Volt$\\
\multicolumn{5}{l}{\textbf{Input/Output}}
\\
 $\mathbf{Output.Prefix}$
& string
& Sets the prefix to the filename used for output. The internal output routine and the loadable
                  hook functions will append their respective postfix and extensions to form the complete output
                  filename.
& none
& none\\
\end{longtable}

\subsubsection{Device DC Sweep Mode}
The DC Sweep Mode is selected by setting $\mathbf{type=DCSweep}$. In this mode, Genius scans
          the external voltage (or current) source at the contact selected in the
$\mathbf{VScan}$ parameter. At each voltage (or current) step, the device equations are solved in steadystate.
\par
\marginhead{Failure Recovery}When the numerical solver fails to converge at a particular step, Genius recovers to the state of the
            previous converged step, reduces the step, and attempts to solve the equations again. In
$\mathbf{DCSweep}$ mode, the voltage or current step is recursively halved when the solver
            diverges. When the solver converges at some reduced step, it tries to progressively double the step it
            recovers to the initial step ($\mathbf{VStep}$ or $\mathbf{IStep}$).
\par
\par
\subsubsection{Device Transient Mode}
The Transient Mode is selected by setting $\mathbf{type=Transient}$. In this mode, external
          sources (electrical or optical sources) vary as time progresses, and Genius solves the device equation with
          the time partial-derivative included.
\par
\marginhead{Initial State}An initial device state must be prepared prior to the transient simulation, otherwise the device state
            at time zero is undetermined. Either a DC Sweep, an Operation Point or a Transient simulation can fulfill
            this requirement.
\par
\par
\marginhead{Adaptive Time Step}In the $\mathbf{Transient}$ mode, one can specify whether adaptive time step is used with
            the option $\mathbf{AutoStep}$. When adaptive step is turned off, the initial timestep
$\mathbf{TStart}$ is used throughout the simulation. With $\mathbf{AutoStep}$
turned
            on, the initial time step $\mathbf{TStep}$ is used in the first few steps, and the time-domain
            truncation error is evaluated. If the truncation error exceeds that specified in
$\mathbf{TS.rTol}$ and $\mathbf{TS.aTol}$, the timestep is reduced to 0.9 of the
            previous value. On the other hand, when the truncation error meets the tolerance criteria, time step is
            increased by the factor of 1.1, until the maximum timestep
$\mathbf{TStepMax}$ is
            reached.
\par
\par
One can use the $\mathbf{VStepMax}$ and $\mathbf{IStepMax}$ parameters to limit
          the maximum change in voltage (current) of any voltage (current) source during any time step. When any driving
          source has a sudden change, the time step will be reduced accordingly.
\par
As in the DC Sweep mode, Genius will recover from convergence failure in the Transient mode, cut the
          time step to half, and continue solving.
\par
\subsubsection{Device Operation Point Mode}
The Operation Point (OP) mode is selected by setting $\mathbf{type=OP}$, and is commonly
          used to bring the device to a steady-state condition, as the starting state for a DC Sweep or Transient
          simulation. For better convergence, Genius will ramp up the voltage and current sources from equilibrium
          (zero) to the specified source values. To limit the maximum change in source values in each ramp-up step, one
          can set the $\mathbf{VStepMax}$ and $\mathbf{IStepMax}$
parameters.
\par
\marginhead{Pseudo-Time Method}New in 1.7.2. In $\mathbf{OP}$ mode for device simulation, pseudo-time method can be used
            to better handle ill-conditioned problems, e.g. devices with floating regions, which are traditionally
            difficult to converge and requires a direct linear solver. With the more numerically stable pseudo-time
            method, such difficult problems can converge with iterative linear solvers such as
$\mathbf{BCGS}$, drastically reducing memory consumption of large-scale problems. In benchmark
            tests, the pseudo-time method (with BCGS) is modestly faster than traditional steady-state method with the
            MUMPS direct linear solver.
\par
\par
The flowchart of the pseudo-time method is shown in \figref{fig:CmdRef:SolveOP:flowchart},
p. \pageref{fig:CmdRef:SolveOP:flowchart},
          with comparison to the normal steady-state method.
\par
\begin{figure}[H]
\caption{\label{fig:CmdRef:SolveOP:flowchart}Floatchart of the Device Operation Point}
%\includegraphics[scale=800]{plotCmdRef/flowchart/pseudotime.pdf}
\end{figure}

Under the pseudo-time scheme, an artificial time-derivative term is added to the electron and hole
          continuity equations in semiconductor regions ($\partial n/\partial t$
and $\partial p/\partial t$) . At the same time, an artificial capacitance ($\partial V/\partial t$) is added between any resistive metal region and the ground. The
          system of equations is thus solved in transient mode with the nominal time step specified by the
$\mathbf{pseudotime.step}$ parameter.
\par
The transient simulation consists of two stages, as shown in \figref{fig:CmdRef:SolveOP:flowchart},
p. \pageref{fig:CmdRef:SolveOP:flowchart}. In the first stage, voltage and current sources are ramped up.
          After the target voltage/current are set, Genius solves the equations for a few further steps in the second
          stage. As time progresses, the device settles down to its steady state, and the change of internal variables
          (e.g. $V$, $n$, and $p$)
          between subsequent steps diminishes. After this change drops below the error threshold, the device is deemed
          to have reached steady-state, and the pseudo-time algorithm completes.
\par
As in the transient and DC sweep modes, in the OP mode, Genius will recover from convergence failure,
          cut back ramp step or time step, and continue solving.
\par
\subsubsection{Device Small-Signal AC Sweep Mode}
The AC Sweep Mode is selected by setting $\mathbf{type=ACSweep}$. In this mode, a
          small-signal sinusoidal sources is applied on the contact specified by the
$\mathbf{VScan}$ parameter, and the AC response of the device is simulated. Before the AC simulation, A steady-state device
          state must be prepared by means of OP or DC Sweep simulation.
\par
\subsubsection{Device/Circuit Mixed Operation Point Mode}
When a circuit netlist is present, the device/circuit mixed OP Mode is selected by setting
$\mathbf{type=OP}$.
\par
\subsubsection{Device/Circuit Mixed DC Sweep Mode}
When a circuit netlist is present, the device/circuit mixed DC Sweep Mode is selected by setting
$\mathbf{type=DCSweep}$.
\par
\subsubsection{Device/Circuit Mixed Transient Mode}
When a circuit netlist is present, the device/circuit mixed Transient Mode is selected by setting
$\mathbf{type=Transient}$.
\par
\subsubsection{Example}
\begin{lstlisting}[style=GeniusCode]
SOLVE  Type=Equilibrium

SOLVE  Type=DCSWEEP Vscan=Anode Vstart=0.0 Vstep=0.05 \
       Vstop=0.8 out.prefix=diode_iv

SOLVE  Type=Transient TStart=0 TStep=1e-12 TStepMax=1e-6 \
       TStop=100e-6
\end{lstlisting}
\subsection{EMFEM2D}
\index{EMFEM2D command}The $\mathbf{EMFEM2D}$
command instructs the 2D finite-element EM wave solver to solve the
        Maxwell equations.
\par
\begin{lstlisting}[style=GeniusCmd]
EMFEM2D
  [ WaveLength=<<num>> ]  [ Intensity=<<num>> ]
  [ Quan.Eff=<<num>> ] [ SpectrumFile=<<str>> ]
  [ wTE=<<num>> ] [ wTM=<<num>> ] [ phase.TE=<<num>> ] [ phase.TM=<<num>> ] [ Angle=<<num>> ]
  [ ABC.Type= ( FirstOrder | SecondOrder | PML ) ]
  [ ABC.Shape= ( Circle | Ellipse | Unknow ) ]
  [ LS = (CGS|BICG|BCGS|GMRES|TFQMR|LU|UMFPACK|SuperLU|
          MUMPS|SuperLU_Dist) ]
  [ PC = (Identity|Jacobian|BJacobian|ASM|ILU) ]
\end{lstlisting}
\par
\subsubsection{Parameters}
\par
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
 $\mathbf{WaveLength}$
& numeric
& The Wave length of the simulation. Synonym: $\mathbf{Lambda}$.
& 0.532
& $\uMeter$
\\
 $\mathbf{Intensity}$
& numeric
& Name of the TIF file to import from.
& 0.0
& $\Watt\Per\Square\cMeter$
\\
 $\mathbf{Quan.Eff}$
& numeric
& Quantum efficiency for photo-generation.
& 1.0
& none
\\
 $\mathbf{SpectrumFile}$
& string
& Read wavelength, intensity and quantum efficiency from a text file.
& none
& none
\\
 $\mathbf{wTE}$
& numeric
& The weight of TE mode in the total intensity.
& 0.5
& none
\\
 $\mathbf{wTM}$
& numeric
& The weight of TM mode in the total intensity.
& 0.5
& none
\\
 $\mathbf{Phase.TE}$
& numeric
& The initial phase of the TE mode.
& 0.0
& degree
\\
 $\mathbf{Phase.TM}$
& numeric
& The initial phase of the TM mode.
& 0.0
& degree
\\
 $\mathbf{Angle}$
& numeric
& The direction of incident plane wave, measured in degrees from the +x axis to the wave
                  vector.
& 90
& degree
\\
 $\mathbf{ABC.Type}$
& enum
& The type of absorbing boundary condition used at the outer boundary of the simulation.
& $\mathbf{SecondOrder}$
& none
\\
 $\mathbf{ABC.Shape}$
& enum
& Inform Genius the shape of absorbing boundary. When the shape is known to be
$\mathbf{Circle}$ or $\mathbf{Ellipse}$, the calculation of boundary curvature
                  can be accelerated.
& $\mathbf{Uknow}$
& none
\\
 $\mathbf{LS}$
& enum
& Selects the linear solver algorithm.
& $\mathbf{BCGS}$
& none
\\
 $\mathbf{PC}$
& enum
& Selects the linear preconditioner algorithm.
& $\mathbf{ILU}$
& none\\
\end{longtable}

\subsubsection{Description}
The spectrum file is a plain text file with each line for one frequency point in the spectrum. Each line
          contains 2 or 3 numerical values separated by whitespaces:
\par
\begin{lstlisting}[language=sh]
<wavelength>  <intensity>  [quantum efficiency]
\end{lstlisting}
Genius will perform FEM EM simulation at each frequency point, calculate the optical generation at each
          frequency, and sum up the total carrier generation.
\par
When quantum efficiency is given, Genius will use this value to calculate the optical carrier generation
          rate. Otherwise, Genius will use the following quantum efficiency
\par
\begin{equation}
\eta = \frac {\mathop{floor}\nolimits (\hbar \nu / E_g ) \cdot E_g } {\hbar \nu}
\end{equation}
The sum of weights $\mathbf{wTE}$ and $\mathbf{wTM}$ must be $1$. When either
$\mathbf{wTE}$ or $\mathbf{wTM}$ is given, Genius
          will calculate the other automatically. If both values are given, Genius will check if they add up to
          unity.
\par
\marginhead{Absorbing Boundary}The absorbing boundary condition can be first-order or second-order, and can be selected by the
$\mathbf{ABC.Type}$ parameter. In general, the second-order boundary is preferred. When
            possible, a circular shape absorbing boundary is highly recommended. The ABC should be at least one
            wave-length away from the scatterer.
\par
\par
\marginhead{Mesh Size}In FEM EM simulation, the mesh size should be
$1/16$ to $1/20$ of the optical wavelength in the material. Note that wavelength decreases for
            materials with relative permittivity greater than 1. As a result, the mesh in dielectric materials (such as
            Si) should be finer.
\par
\par
\par
\subsection{RAYTRACE}
\index{RAYTRACE command}The $\mathbf{RAYTRACE}$
command instructs the ray-tracing solver to calculate the light
        propagation.
\par
\begin{lstlisting}[style=GeniusCmd]
RAYTRACE
  {
    SpectrumFile=<<str>> |
    ( Lambda=<<num>> Intensity=<<num>> [Quan.Eff=<<num>>] )
  }
  [ Theta=<<num>> ] [ Phi=<<num>> ] [ Ray.Density=<<num>> ]
\end{lstlisting}
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
 $\mathbf{SpectrumFile}$
& string
& Filename of the spectrum file. This file should describe the wavelength and intensity at each
                  frequency in the spectrum.
& $\mathbf{none}$
& none
\\
 $\mathbf{Lambda}$
& numerical
& Wavelength of the monochromatic light. Synonym: $\mathbf{Wavelength}$
& $\mathbf{0.532}$
& $\uMeter$
\\
 $\mathbf{Intensity}$
& numerical
& Intensity of the monochromatic light.
& $\mathbf{0.0}$
& $\Watt\Per\Square\cMeter$
\\
 $\mathbf{Quan.Eff}$
& numerical
& Quantum efficiency of carrier generation for the monochromatic light. If not explicitly
                  specified, Genius will automatically calculate the quantum efficiency using the bandgap of the
                  material.
& $\mathbf{auto}$
& none
\\
 $\mathbf{Theta}$
& numerical
& Azimuth angle of the wave vector of the incident light.
& 0
& degree
\\
 $\mathbf{Phi}$
& numerical
& Inclination angle of the wave vector of the incident light, measured from the y-axis.
& 0
& degree
\\
 $\mathbf{E.Theta}$
& numerical
& Azimuth angle of the E-vector of the incident light.
& 0
& degree
\\
 $\mathbf{E.Phi}$
& numerical
& Inclination angle of the E-vector of the incident light, measured from the y-axis.
& 90
& degree
\\
 $\mathbf{Ray.Density}$
& numerical
& Density of light rays. In 2D structures, each mesh element is expected to have at least
$\mathbf{Ray.Density}$ number of rays. In 3D structures, each mesh element has at least
$\mathbf{Ray.Density}$*$\mathbf{Ray.Density}$ number of rays.
& 10
& none\\
\end{longtable}

\subsubsection{Description}
The direction of the incident wave is specified by the azimuth and inclination angle
$\theta$ and $\phi$, and the direction unit vector can be
          expressed as
\par
\begin{equation}
\vec{r}=\left(\begin{array}{c}
\sin\phi\cos\theta\\
\cos\phi\\
\sin\phi\sin\theta
\end{array}\right)
\end{equation}
The default values of $\mathbf{Theta}$ and $\mathbf{Phi}$ corresponds to
          incidence along the positive y-axis direction.
\par
\marginhead{Ray Seeding}Genius seeds the incident light rays automatically. The density of rays is determined by the smallest
            element in device mesh and the parameter $\mathbf{ray.density}$. The ray to ray distance is set
            to D=$d_{\rm min}$/$\mathbf{ray.density}$. In general, Genius
            guarantees that each mesh element has at least $\mathbf{ray.density}$
rays in 2D structures, and $\mathbf{ray.density}$*$\mathbf{ray.density}$
rays in 3D structures,
            respectively.
\par
\par
\marginhead{Boundaries}When a ray incidents on Ohmic boundaries and Schottky boundaries, the tracing terminates and the
            incident ray is removed. If a Neumann boundary has the
$\mathbf{Reflection}$ parameter set to {\ttsl true} (default is {\ttsl
false}), the above rule also
            applies.
\par
\par
On the other hand, the interfaces with metallic (electrode) regions are not affected by the above rule,
          and refraction/reflection rays are generated.
\par
\marginhead{Absorption}When the ray passes though a mesh element, the optical power associated to the ray deposits in this
            element according to the absorption coefficient. Genius will sum the power deposited by all the rays and
            calculate the optical carrier generation rate at each node.
\par
\par
\marginhead{Spectrum file}With the spectrum file we can specify multi- spectrums of light with different intensity. Spectrum
            file should contain at lease two spectrums. Each line in the spectrum file should have the following
            columns
\begin{compactitem}
\item The wavelength in the unit of micro-meter.
\par
\item Intensity density (per unit wavelength) at this wavelength. The unit is
$\Watt\Per\Square\cMeter\Per\uMeter$. Note that this differs from the
$\mathbf{intensity}$ parameter for monochromatic light.
\par
\item (Optional) quantum efficiency for carrier generation. If not explicitly specified, Genius will
                  automatically calculate the quantum efficiency using the bandgap of the material.
\par
\end{compactitem}
\par
\par
A sample spectrum file is listed below.
\par
\begin{lstlisting}[language=sh]
# lambda    intensity
  0.912     0.2
  0.954     0.5
  1.00      0.4
  1.05      0.3
  1.11      0.2
  1.17      0.2
  1.24      0.1
\end{lstlisting}
\par
\subsubsection{Example}
\begin{lstlisting}[style=GeniusCode]
RayTrace wavelength=0.4 intensity=0.1 k.phi=0 ray.density=10.0
RayTrace SpectrumFile=am15a.txt k.phi=0 ray.density=10.0
\end{lstlisting}
\section{Input and Output}
\par
\subsection{IMPORT}
\index{IMPORT command}The $\mathbf{IMPORT}$
command loads mesh structures and solutions from a file, and builds
        the simulation system based on it.
\par
\begin{lstlisting}[style=GeniusCmd]
IMPORT
  { CGNSFile=<<str>> | TIFFile=<<str>> | TIF3DFile=<<str>> |
    SilvacoFile=<<str>> | ISEFile=<<str>> }
\end{lstlisting}
\par
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
$\mathbf{CGNSFile}$
& string
& Name of the CGNS file to import from.
& $\mathbf{none}$
& none
\\
 $\mathbf{TIFFile}$
& string
& Name of the TIF file to import from.
& $\mathbf{none}$
& none
\\
 $\mathbf{TIF3DFile}$
& string
& Name of the TIF3D file to import from.
& $\mathbf{none}$
& none
\\
 $\mathbf{SilvacoFile}$
& string
& Name of the Silvaco str file to import from.
& $\mathbf{none}$
& none
\\
 $\mathbf{ISEFile}$
& string
& Name of the DF-ISE file to import from.
& $\mathbf{none}$
& none\\
\end{longtable}

\par
\subsubsection{description}
Genius can load device definition and data from many different files. The CFD General Notation System
          (CGNS) is the native file supported by Genius. User can save the current state of device under simulation by
$\mathbf{EXPORT}$ command and then load it again by $\mathbf{IMPORT}$
command. Besides the
          native CGNS format. Genius can also load device structure from Technology Interchange Format (TIF) format
          which is commonly used by Synopsys medici and tsuprem, DF-ISE format used by Synopsys Sentaurus, structure
          format used by Silvaco, and a externed TIF3D file generated by Gds2mesh tool.
\par
\subsubsection{Example}
\begin{lstlisting}[style=GeniusCode]
IMPORT    CGNSFile = "foo.cgns"
IMPORT    TIFFile  = "foo.tif"
\end{lstlisting}
\par
\subsection{EXPORT}
\index{EXPORT command}The $\mathbf{EXPORT}$
command saves mesh structures and solutions to a file.
\par
\begin{lstlisting}[style=GeniusCmd]
EXPORT
  [ CGNSFile=<<str>> ] [ VTKFile=<<str>> ] [ ISEFile=<<str>> ]
  [ BCInfo=<<str >>]
  { [ NodeInfo=<<str >>] [ LUnit = (m|cm|um|nm) ]
    [ Numbering=<<bool>> ] }
\end{lstlisting}
\par
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
 $\mathbf{CGNSFile}$
& string
& Export the mesh and data in the CGNS file with the supplied file name.
& $\mathbf{none}$
& none
\\
 $\mathbf{VTKFile}$
& string
& Export the mesh and data in the VTK file with the supplied file name.
& $\mathbf{none}$
& none
\\
 $\mathbf{ISEFILE}$
& string
& Export device mesh and doping information in the DF-ISE format into two files with supplied
                    file name and .grd and .dat file extersion, respectively.
& $\mathbf{none}$
& none
\\
 $\mathbf{BCFile}$
& string
& Export the boundary condition definition of the structure to the file, which can be loaded in
                    another Genius input file with an $\mathbf{INCLUDE}$
command.
& $\mathbf{none}$
& none
\\
 $\mathbf{NodeFile}$
& string
& Export the coordinates of the mesh points to a plain text file with the supplied file
                    name.
& $\mathbf{none}$
& none
\\
 $\mathbf{LUnit}$
& enum
& Length unit used for node coordinates, when exporting to $\mathbf{NodeFile}$.
& $\mathbf{um}$
& none
\\
 $\mathbf{Numbering}$
& bool
& Whether to print node number in $\mathbf{NodeFile}$.
& $\mathbf{true}$
& none\\
\end{longtable}

\par
\subsubsection{description}
Genius can save device definition and data to files in the CFD General Notation System (CGNS) which is
          natively supported. Genius also saves mesh and solution data with the Visualization ToolKit (VTK) formats
          which is supported by VisualTCAD and many other post-process tool such as Paraview and Visit. Since version
          1.7, Genius can export device mesh and doping information in the DF-ISE format.
\par
\subsubsection{Example}
\begin{lstlisting}[style=GeniusCode]
EXPORT    CGNSFile = "foo.cgns"
EXPORT    CGNSFile = "foo.cgns" VTKFile="bar.vtk"
EXPORT    ISEFile = "foo"
\end{lstlisting}
\par
\subsection{HOOK}
\index{Hook command}The $\mathbf{HOOK}$
command loads or unloads hook functions, which are called before and
        after solving the device equations. Various hook functions are available that serve as pre-/post-processors,
        input/output formatters and interface with other softwares.
\par
\begin{lstlisting}[style=GeniusCmd]
HOOK
  [ Load=<<str>> [ real<<<str>>>=<<num>> [...] ] [ str<<<str>>>=<<str>> [...] ]
  [ Unload=<<str>> ]
\end{lstlisting}
\subsubsection{Parameters}
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
 $\mathbf{Load}$
& string
& Name of the hook function to be loaded.
& $\mathbf{none}$
& none
\\
 $\mathbf{real<str>}$
& numerical
& Custom numerical parameters for the loaded hook function.
& $\mathbf{none}$
& none
\\
 $\mathbf{string<str>}$
& string
& Custom string parameters for the loaded hook function.
& $\mathbf{none}$
& none
\\
 $\mathbf{Unload}$
& enum
& Name of the hook function to be unloaded.
\par
& $\mathbf{none}$
& none\\
\end{longtable}

\par
\subsubsection{Description}
The $\mathbf{HOOK}$ command should be invoked before the $\mathbf{SOLVE}$
command to be
          effective. Some hooks are only compatible with some of the analysis modes (e.g. with DC Sweep mode only).
          After a hook is loaded, it is effective in subsequent
$\mathbf{SOLVE}$ commands as well if the hook
          function is compatible with the analysis mode, until it is unloaded.
\par
Some hooks accepts custom parameters when the user loads them. If one tries to load a previously loaded
          hook function again, the parameters specified during previous loading are all erased.
\par
\subsubsection{Default Hook Functions}
The following hook functions are loaded by default.
\par
\begin{compactitem}
\item $\mathbf{gnuplot}$. Save the terminal voltages and currents from the simulation result
              in plain text format, which is compatible with the
\FilenameType{gnuplot} ploting program. This hook
              is
\par
\item $\mathbf{raw}$. Save the terminal voltages and currents from the simulation result in
              the SPICE raw format. The output file has the extention
\FilenameType{.raw}.
\par
\end{compactitem}
Additionally, a few optional hook functions are available, and the user can load some of them with the
$\mathbf{HOOK}$ command. In the following sections, we briefly describe each of them.
\par
\subsubsection{CV Postprocessor}
The $\mathbf{cv}$ hook function extracts the capacitance of gate electrodes. One can load
          this postprocessor with the command
\begin{lstlisting}[style=GeniusCode]
HOOK    Load=cv
\end{lstlisting}
and the extracted capacitance-voltage data will be saved in output file with the extension
\FilenameType{.cv}. The electric charge in the gate electrodes are first integrated, and capacitance is
          then extracted by differentiating with respect to the scanning voltage. It works in the DC voltage sweep mode
          only and the extracted capacitance is quasi-static. For capacitance analysis at high frequency, one should use
          the AC analysis mode.
\par
\subsubsection{Probe Postprocessor}
The $\mathbf{probe}$ hook function allows the user to monitor the potential and carrier
          concentration at a particular point in the device. It can be loaded with the following command
\begin{lstlisting}[style=GeniusCode]
HOOK    Load=probe real<x>=1.0 real<y>=1.2
\end{lstlisting}
where the following custom parameters are recognized.
\par
\begin{longtable}{ll>{\raggedright}p{0.4\linewidth}ll}
\textbf{Parameter} & \textbf{Type} & \textbf{Description} & \textbf{Default} & \textbf{Unit} \\
 $\mathbf{x}$
& numerical
& The x-coordinate of the probe.
& $\mathbf{0}$
& $\uMeter$
\\
 $\mathbf{y}$
& numerical
& The y-coordinate of the probe.
& $\mathbf{0}$
& $\uMeter$
\\
 $\mathbf{z}$
& numerical
& The z-coordinate of the probe.
& $\mathbf{0}$
& $\uMeter$\\
\end{longtable}

\subsubsection{Visualization and Animation Postprocessor}
The vtk hook function allows the user to save VTK file at each step in DC and transient simulation. The
          serial of VTK files which contains field evolving information can be viewed by VisualTCAD, Paraview or Visit.
          Furthermore, user can make animation with the serial of VTK files with Paraview or Visit.
\par
\subsubsection{Interface to Visit visualizer}
Genius can feed solution to the visualizer program Visit through the
$\mathbf{visit}$ hook
          function.
\par
\chapter{Extending Genius Simulator}
The Genius device simulator can be extended by users in several ways.
\par
\begin{compactitem}
\item Through the physical model interface (PMI), new materials can be added and existing materials can be
        modified.
\par
\item Pre-processing and post-processing steps can be added through the hook interface.
\par
\item The simulator is programmable through its Python interface.
\par
\end{compactitem}
This chapter outlines the procedure of extending Genius with the various interfaces. This chapter is intended
    for advanced readers who intend to write programs to customize or extend the Genius simulator. An intermediate level
    of knowledge about the C++ programming language and the development tools in Linux or Windows.
\par
\section{Custom Material Models}
\par
\subsection{Overview of PMI}
Each material in Genius is packaged as a dynamically linked library (DLL). With this design, new materials
        can be added, and existing materials modified, without the need of re-building the entire simulator.
\par
\subsubsection{Files}
The material library files are located in the directory \FilenameType{\$GENIUS\_DIR/lib}. The
          filename for material {\ttsl foo} is \FilenameType{libfoo.so}.
\par
\marginhead{Material Catalog File}In addition to the material's DLL, an entry in the catalog file
\FilenameType{\$GENIUS\_DIR/lib/material.def} is needed for the material model to function properly in
            Genius. Below is a few entries in \FilenameType{material.def}.
\par
\par
\begin{lstlisting}[language=sh]
Si
{
    property = Semiconductor
    alias    = Silicon
    color    = 0xffb6c1ff
}

GaAs
{
    property = Semiconductor
    color    = 0xeaeaeaff
}

AlGaAs
{
    # mole dependence: Ga(1-x)Al(x)As
    property = SingleCompoundSemiconductor
    color    = 0xa6d6d6ff
}

SiO2
{
    property = Insulator
    alias    = Ox
    alias    = Oxide
    color    = 0x7d0505ff
}

\end{lstlisting}
Each entry corresponds to a material. An entry starts with material's ID and the content of the entry is
          contained in the pair of curly braces. The content is a list of parameter=value pairs, each in its own line.
          The parameter $\mathbf{property}$ specifies the type of the material, the possible values
          are
\par
\begin{compactitem}
\item $\mathbf{Semiconductor}$: Elemental and simple compound semiconductors with fixed
              compositions.
\par
\item $\mathbf{SingleCompoundSemiconductor}$: Compound semiconductors with a single mole
              fraction number.
\par
\item $\mathbf{ComplexCompoundSemiconductor}$: Complex compound semiconductors, with more than
              one mole fraction number.
\par
\item $\mathbf{Conductor}$: metals and metallic poly-silicon
\par
\item $\mathbf{Vacuum}$: only used in optical simulation
\par
\item $\mathbf{PML}$: only used in optical simulations
\par
\end{compactitem}
Each material can have several aliases in addition to its ID. In the
$\mathbf{Material}$ parameter of the $\mathbf{REGION}$ command\index{REGION command!Material Parameter}, one can use either the aliases or the ID of a material.
\par
\subsubsection{Classes}
\begin{figure}[H]
\caption{\label{fig:Extend:PMI:Classes}Class hierarchy of the PMI}
%\includegraphics[scale=600]{plotExtend/PMI\_struct.pdf}
\end{figure}
The class hierarchy of the PMI interface is shown in \figref{fig:Extend:PMI:Classes},
p. \pageref{fig:Extend:PMI:Classes}. The
          abstract base class PMI provides the basic facilities for all physical models. For each category of materials,
          semiconductor, conductor or insulator, there is a class derived from PMI (in the second column). For a
          semiconductor material, there are several 7 aspects of its physics. Every aspect is described in a class, as
          shown in the third column. For insulators and conductors, the physics are simpler. The physics covered by each
          class is summarized below.
\par
\begin{compactitem}
\item BasicParameter: mass density, dielectric permittivity, magnetic permeability and electron
              affinity.
\par
\item BandStructure: bandgap, carrier effective mass, effective density of states,
              generation/recombination, thermoionic emission and (temporarily) band-to-band tunneling.
\par
\item Mobility: carrier mobility, include its degradation at surfaces and carrier velocity
              saturation.
\par
\item Avalanche: impact ionization generation.
\par
\item Trap: carrier capture and emission at trap states.
\par
\item Thermal: thermal conductivity and thermal capacity.
\par
\item Optical: refraction index (real and imaginary parts) at different wavelengths.
\par
\end{compactitem}
All the above classes are abstract and can not be instantiated. When one implements a material, one must
          derive from each of the above classes, and provide a concrete implementation. For example, for the 4H-SiC
          material, the classes in the last column of \figref{fig:Extend:PMI:Classes},
p. \pageref{fig:Extend:PMI:Classes} are implemented and
          packed in the dynamic library \FilenameType{libSiC4H.so}.
\par
Since dynamic libraries has a C interface (instead of a C++ one), a creator function with C-style name
          and calling convention, must accomany each concrete class in the dynamic library. For example, the C function
\IdentifierType{PMIS\_SiC4H\_BandStructure\_Default} in the library
\FilenameType{libSiC4H.so} is
          responsible for creating an instance of the class \IdentifierType{GSS\_SiC4H\_BandStructure}.
\par
\subsubsection{How a PMI Library is Loaded}
We shall describe the loading sequence of physical models, assuming the following two commands appear in
          the input file to Genius.
\par
\begin{lstlisting}[style=GeniusCode]
# MESH commands
# ...
REGION Label=Substrate Material=Silicon
REGION Label=GOX Material=SiO2
#----------------

# ...
PMI Region=Substrate Type=Mobility Model=HP
PMI Region=Substrate Type=Avalanche Model=HP
\end{lstlisting}
The $\mathbf{REGION}$ commands are read in first, together with the meshing commands. After all
          the structure specification commands are read, the initial simulation system is built. For the region
$\mathbf{Substrate}$, the default material models for silicon are loaded. For the region GOX, the
          default models for SiO\low{2} are loaded.
\par
After the simulation system is built, the rest of the commands, including those
$\mathbf{PMI}$ commands are executed sequentially. When the first PMI command is executed, the region
$\mathbf{Substrate}$ is looked up and found to be of material silicon. The dynamic library
\FilenameType{libSi.so} is loaded. From the material name, the model type Mobility, the model name HP,
          we assemble the creator function's name \IdentifierType{PMIS\_Si\_Mob\_HP}. This creator function is called,
          which returns an object instance of the class \IdentifierType{GSS\_Si\_Mob\_HP}. This
\IdentifierType{GSS\_Si\_Mob\_HP} class, as a derived class of \IdentifierType{PMIS\_Mobility},
          contains routines for calculating carrier mobility and velocity saturation.
\par
\subsubsection{How a PMI Library is Used}
When the Genius simulator assemble the Poisson and continuity equations set out in
\nameref{sec:Equation:DDML1}, p. \pageref{sec:Equation:DDML1}, material properties, such as doping concentration and mole fraction are
          available only at each of the grid nodes. Many derived physical quantities, such as carrier mobility and SRH
          recombination rate, are evaluated at each mesh node as well. This is best illustrated with an example.
\par
Suppose when we assemble the carrier continuity equation, we need to calculate the bandgap narrowing due
          to heavy doping at a grid node. We know the material of the current mesh node is 4H-SiC, and from
\figref{fig:Extend:PMI:Classes}, p. \pageref{fig:Extend:PMI:Classes}, the PMI class that handles the bandgap narrowing physics is
\IdentifierType{GSS\_SiC4H\_BandStructure}. In fact, as a sub-class of
\IdentifierType{PMIS\_BandStructure}, it has a method \IdentifierType{EgNarrow}
that calculates
          bandgap narrowing. The definition of the method is shown below, also shown is the method
\IdentifierType{nie} that calculates the effective intrinsic carrier concentration.
\par
\begin{lstlisting}[language={C++}]
class GSS_SiC4H_BandStructure : public PMIS_BandStructure
{
  //...

public:
  double EgNarrow(const double &p, const double &n,
                  const double &Tl)
  {
    double Na = ReadDopingNa();
    double Nd = ReadDopingNd();
    double N = Na+Nd+1.0*std::pow(cm,-3);
    double x = log(N/N0_BGN);
    return V0_BGN*(x+sqrt(x*x+CON_BGN));
  }

  double nie (const double &p, const double &n,
              const double &Tl)
  {
    double bandgap = Eg(Tl);
    double Nc = NC300*std::pow(Tl/T300,NC_F);
    double Nv = NV300*std::pow(Tl/T300,NV_F);
    return sqrt(Nc*Nv)*exp(-bandgap/(2*kb*Tl))
             *exp(EgNarrow(p, n, Tl));
  }

  // ...
};
\end{lstlisting}
It is obvious that this few lines implements the Slotboom model of bandgap narrowing
\par
\begin{equation}
\Delta E_g = \frac{E_{\rm bgn}}{2k_b T}\left[ \ln \frac{N_{\rm total}}{N_{\rm ref}} + \sqrt
            {\left( \ln \frac{N_{\rm total}}{N_{\rm ref}} \right)^2 + C_{\rm bgn}} \right].
\end{equation}
In this simple model, neither the electron, hole concentration nor the lattice temperature affects the
          bandgap narrowing. Therefore the arguments are ignored. The model chiefly relies on the doping concentration.
          The \IdentifierType{ReadDopingNa} and \IdentifierType{ReadDopingNd}
methods, inherited from
          the \IdentifierType{PMIS\_Server} class, returns the acceptor and donor concentrations at the present
          mesh node, respectively.
\par
It is also necessary to evaluate the partial derivatives of the bandgap narrowing, with respective to
          all unknowns in the system of equations. This may sound an involved task. However, Genius uses the automatic
          differentiation technology which hides most of the complications from the user. The following snippet shows
          the method that calculates the partial derivatives. It is also named
\IdentifierType{EgNarrow}, but
          note the difference in the type of arguments.
\par
\begin{lstlisting}[language={C++}]
class GSS_SiC4H_BandStructure : public PMIS_BandStructure
{
  //...

public:

  AutoDScalar EgNarrow(const AutoDScalar &p, const AutoDScalar &n,
                       const AutoDScalar &Tl)
  {
    double Na = ReadDopingNa();
    double Nd = ReadDopingNd();
    double N = Na+Nd+1.0*std::pow(cm,-3);
    double x = log(N/N0_BGN);
    return V0_BGN*(x+sqrt(x*x+CON_BGN));
  }

  AutoDScalar nie (const AutoDScalar &p, const AutoDScalar &n,
                   const AutoDScalar &Tl)
  {
    AutoDScalar bandgap = Eg(Tl);
    AutoDScalar Nc = NC300*adtl::pow(Tl/T300,NC_F);
    AutoDScalar Nv = NV300*adtl::pow(Tl/T300,NV_F);
    AutoDScalar ret=sqrt(Nc*Nv)*exp(-bandgap/(2*kb*Tl))
                      *exp(EgNarrow(p, n, Tl));
    return ret;
  }
  // ...

};
\end{lstlisting}
It is clear that the "derivative" version of \IdentifierType{EgNarrow}
and \IdentifierType{nie} are almost identical to the "normal" version. In almost all situations, it is
          sufficient to replace the scalar type double with the class type
\IdentifierType{AutoDScalar}.
\par
\subsection{Procedure of Building a Custom Material Library}
The procedure of building a custom material library is outlined in this section.
\par
\subsubsection{Building the Example}
\marginhead{Step 1}Run the configure script.
\par
\par
\begin{lstlisting}[language=sh]
cd examples/Material
./configure.sh
\end{lstlisting}
\marginhead{Step 2}Enter the material directory and modify the source files as needed.
\par
\par
\begin{lstlisting}[language=sh]
cd 4H-SiC
\end{lstlisting}
\marginhead{Step 3}Build the material library.
\par
\par
\begin{lstlisting}[language=sh]
make
\end{lstlisting}
\par
\marginhead{Step 4}Copy the library file \FilenameType{libSiC4H.so}
to \FilenameType{\$GENIUS\_DIR/lib/},
            backing up the old file is strongly recommended. The new material library is ready for use now.
\par
\par
\subsubsection{Create a New Material Library}
\par
\marginhead{Step 1}Make a copy of some existing model.
\par
\par
\begin{lstlisting}[language=sh]
cp -R 4H-SiC 6H-SiC
\end{lstlisting}
\marginhead{Step 2}Replace the material name string in the all source files, with the new material name, and rename the
            files.
\par
\par
\begin{lstlisting}[language=sh]
sed -i -e "s/SiC4H/SiC6H/g" makefile
sed -i -e "s/SiC4H/SiC6H/g" *.cc
rename "s/4H-SiC/6H-SiC/" *.cc
\end{lstlisting}
\marginhead{Step 3}Edit the source, and build the material library.
\par
\par
\begin{lstlisting}[language=sh]
cd 6H-SiC
make
\end{lstlisting}
\marginhead{Step 4}Copy the library file \FilenameType{libSiC4H.so}
to \FilenameType{\$GENIUS\_DIR/lib/},
                and edit the catalog file \textdollar{}GENIUS\_DIR/lib/material.def
\par
\par
\begin{lstlisting}[language=sh]
SiC6H
{
    property = Semiconductor
    alias    = 6HSiC
    color    = 0xffb6c1ff
}
\end{lstlisting}
The new material library is ready for use now.
\par
\par
\subsection{Class References}
The class reference presented here is a selected and adapted version of the classes declared in the PMI
        development kit. Some macros are expanded and some internal details are omitted, so that this guide is easier to
        follow.
\par
\subsubsection{PMI\_Server Class}
\label{sec:Extend:PMI:Ref:PMI}
\begin{lstlisting}[language={C++}]
PMI_Server(const PMI_Environment &env);
\end{lstlisting}
Constructor.
\par
\begin{lstlisting}[language={C++}]
void ReadCoordinate (double& x, double& y, double& z) const
\end{lstlisting}
Return the spatial coordinates of the mesh node.
\par
\begin{lstlisting}[language={C++}]
double ReadTime() const
\end{lstlisting}
Return the current time in simulation. This is only meaningful in transient-mode simulations.
\par
\begin{lstlisting}[language={C++}]
double ReadUserScalarValue (std::string &name) const
\end{lstlisting}
Return the scalar value with the given name at the current node. An examples of the scalar values at a
            node is the density of trap state.
\par
\subsubsection{PMIS\_Server Class}
\label{sec:Extend:PMI:Ref:PMIS}
\par
\begin{lstlisting}[language={C++}]
double ReadxMoleFraction () const
\end{lstlisting}
Return the mole fraction x at the current node. Only used in compound
            semiconductor with variable compositions.
\par
\begin{lstlisting}[language={C++}]
double ReadxMoleFraction (const double mole_xmin,
                          const double mole_xmax) const
\end{lstlisting}
Return the mole fraction x at the current node, with upper and lower
            limits.
\par
\begin{lstlisting}[language={C++}]
double ReadyMoleFraction () const
\end{lstlisting}
Return the mole fraction y at the current node. Only used in compound
            semiconductor with variable compositions.
\par
\begin{lstlisting}[language={C++}]
double ReadyMoleFraction (const double mole_ymin,
                          const double mole_ymax) const
\end{lstlisting}
Return the mole fraction y at the current node, with upper and lower
            limits.
\par
\begin{lstlisting}[language={C++}]
double ReadDopingNa () const
\end{lstlisting}
Return the acceptor dopant concentration.
\par
\begin{lstlisting}[language={C++}]
double ReadDopingNd () const
\end{lstlisting}
Return the donor dopant concentration.
\par
\subsubsection{PMIS\_BasicParameter Class}
\label{sec:Extend:PMI:Ref:PMIS:Basic}
\begin{lstlisting}[language={C++}]
virtual double Density (const PetscScalar &Tl) const = 0
\end{lstlisting}
Return the mass density $g/cm^{-3}$ of the material.
\par
\begin{lstlisting}[language={C++}]
virtual double Permittivity () const = 0
\end{lstlisting}
Return the relative permittivity of the material.
\par
\begin{lstlisting}[language={C++}]
virtual double Permeability () const = 0
\end{lstlisting}
Return the relative permeability of the material.
\par
\begin{lstlisting}[language={C++}]
virtual double Affinity (const double &Tl) const = 0
\end{lstlisting}
Return the affinity energy [eV] of the material.
\par
\par
\subsubsection{PMIS\_BandStructure Class}
\label{sec:Extend:PMI:Ref:PMIS:Band}
Unless otherwise stated, the arguments of the following methods are
\par
\begin{compactitem}
\item $\mathbf{p}$ hole concentration
\par
\item $\mathbf{n}$ electron concentration
\par
\item $\mathbf{Tl}$ lattice temperature
\par
\item $\mathbf{Tp}$ hole temperature
\par
\item $\mathbf{Tn}$ electron temperature
\par
\end{compactitem}
\begin{lstlisting}[language={C++}]
virtual double      Eg (const PetscScalar &Tl) = 0
virtual AutoDScalar Eg (const AutoDScalar &Tl) = 0
\end{lstlisting}
Return the band gap of semiconductor.
\par
\begin{lstlisting}[language={C++}]
virtual double      EgNarrow (const double      &p,
                              const double      &n,
                              const double      &Tl) = 0
virtual AutoDScalar EgNarrow (const AutoDScalar &p,
                              const AutoDScalar &n,
                              const AutoDScalar &Tl) = 0
\end{lstlisting}
Return the band gap narrowing due to heavy doping.
\par
\begin{lstlisting}[language={C++}]
virtual double      EgNarrowToEc (const double      &p,
                                  const double      &n,
                                  const double      &Tl) = 0
virtual AutoDScalar EgNarrowToEc (const AutoDScalar &p,
                                  const AutoDScalar &n,
                                  const AutoDScalar &Tl) = 0
\end{lstlisting}
Return the conduction band shift due to band gap narrowing.
\par
\begin{lstlisting}[language={C++}]
virtual double      EgNarrowToEv (const double      &p,
                                  const double      &n,
                                  const double      &Tl) = 0
virtual AutoDScalar EgNarrowToEv (const AutoDScalar &p,
                                  const AutoDScalar &n,
                                  const AutoDScalar &Tl) = 0
\end{lstlisting}
Return the valence band shift due to band gap narrowing.
\par
\begin{lstlisting}[language={C++}]
virtual double      EffecElecMass (const double      &Tl) = 0
virtual AutoDScalar EffecElecMass (const AutoDScalar &Tl) = 0
\end{lstlisting}
Return the effective mass of electrons (DOS mass).
\par
\begin{lstlisting}[language={C++}]
virtual double      EffecHoleMass (const double      &Tl) = 0
virtual AutoDScalar EffecHoleMass (const AutoDScalar &Tl) = 0
\end{lstlisting}
Return the effective mass of holes (DOS mass).
\par
\begin{lstlisting}[language={C++}]
virtual double      Nc (const double      &Tl) = 0
virtual AutoDScalar Nc (const AutoDScalar &Tl) = 0
\end{lstlisting}
Return the effective density of states in the conduction band.
\par
\begin{lstlisting}[language={C++}]
virtual double      Nv (const double      &Tl) = 0
virtual AutoDScalar Nv (const AutoDScalar &Tl) = 0
\end{lstlisting}
Return the effective density of states in the valence band.
\par
\begin{lstlisting}[language={C++}]
virtual double ni ( const PetscScalar &Tl) = 0
\end{lstlisting}
Return the intrinsic carrier concentration.
\par
\begin{lstlisting}[language={C++}]
virtual double      nie (const double      &p,
                         const double      &n,
                         const double      &Tl) = 0
virtual AutoDScalar nie (const AutoDScalar &p,
                         const AutoDScalar &n,
                         const AutoDScalar &Tl) = 0
\end{lstlisting}
Return the effective intrinsic carrier concentration.
\par
\begin{lstlisting}[language={C++}]
virtual PetscScalar TAUN (const double &Tl) = 0
virtual PetscScalar TAUP (const double &Tl) = 0
\end{lstlisting}
Return the minority carrier life time due to SHR recombination.
\par
\begin{lstlisting}[language={C++}]
virtual double      R_Direct (const double      &p,
                              const double      &n,
                              const double      &Tl) = 0
virtual AutoDScalar R_Direct (const AutoDScalar &p,
                              const AutoDScalar &n,
                              const AutoDScalar &Tl) = 0
\end{lstlisting}
Return the direct (interband) recombination rate.
\par
\begin{lstlisting}[language={C++}]
virtual double      R_Auger (const double      &p,
                             const double      &n,
                             const double      &Tl) = 0
virtual AutoDScalar R_Auger (const AutoDScalar &p,
                             const AutoDScalar &n,
                             const AutoDScalar &Tl) = 0
\end{lstlisting}
Return the Auger recombination rate.
\par
\begin{lstlisting}[language={C++}]
virtual double      R_Auger_N (const double      &p,
                               const double      &n,
                               const double      &Tl) = 0
virtual AutoDScalar R_Auger_N (const AutoDScalar &p,
                               const AutoDScalar &n,
                               const AutoDScalar &Tl) = 0
virtual double      R_Auger_P (const double      &p,
                               const double      &n,
                               const double      &Tl) = 0
virtual AutoDScalar R_Auger_P (const AutoDScalar &p,
                               const AutoDScalar &n,
                               const AutoDScalar &Tl) = 0
\end{lstlisting}
Return the rates of electron and hole initiated Auger recombination.
\par
\begin{lstlisting}[language={C++}]
virtual double      R_SHR (const double      &p,
                           const double      &n,
                           const double      &Tl) = 0
virtual AutoDScalar R_SHR (const AutoDScalar &p,
                           const AutoDScalar &n,
                           const AutoDScalar &Tl) = 0
\end{lstlisting}
Return the rate of SRH recombination.
\par
\begin{lstlisting}[language={C++}]
virtual PetscScalar R_Surf (const double      &p,
                            const double      &n,
                            const double      &Tl,
                            const double      &len) =0;
virtual AutoDScalar R_Surf (const AutoDScalar &p,
                            const AutoDScalar &n,
                            const AutoDScalar &Tl,
                            const PetscScalar &len) =0;
\end{lstlisting}
Return the rate of SRH recombination.
\par
\begin{lstlisting}[language={C++}]
virtual double      R_SHR (const double      &p,
                           const double      &n,
                           const double      &Tl) = 0
virtual AutoDScalar R_SHR (const AutoDScalar &p,
                           const AutoDScalar &n,
                           const AutoDScalar &Tl) = 0
\end{lstlisting}
Return the rate of SRH and surface recombination at semiconductor-insulator interface.
\par
\begin{lstlisting}[language={C++}]
virtual double      Recomb (const double      &p,
                            const double      &n,
                            const double      &Tl) = 0
virtual AutoDScalar Recomb (const AutoDScalar &p,
                            const AutoDScalar &n,
                            const AutoDScalar &Tl) = 0
\end{lstlisting}
Return the total recombination rate of all recombination mechanisms.
\par
\begin{lstlisting}[language={C++}]
virtual double      ElecEnergyRelaxTime(const double      &Tn,
                                        const double      &Tl) = 0
virtual AutoDScalar ElecEnergyRelaxTime(const AutoDScalar &Tn,
                                        const AutoDScalar &Tl) = 0
\end{lstlisting}
Return the electron energy relaxation time. Used in EBM simulations.
\par
\begin{lstlisting}[language={C++}]
virtual double      HoleEnergyRelaxTime(const double      &Tn,
                                        const double      &Tl) = 0
virtual AutoDScalar HoleEnergyRelaxTime(const AutoDScalar &Tn,
                                        const AutoDScalar &Tl) = 0
\end{lstlisting}
Return the hole energy relaxation time. Used in EBM simulations.
\par
\begin{lstlisting}[language={C++}]
virtual double      SchottyJsn (double      n,
                                double      Tl,
                                double      Vb) = 0
virtual AutoDScalar SchottyJsn (AutoDScalar n,
                                AutoDScalar Tl,
                                AutoDScalar Vb) = 0
\end{lstlisting}
Return the electron current density at Schottky contacts. The argument
$\mathbf{Vb}$ is
            the electron barrier height.
\par
\begin{lstlisting}[language={C++}]
virtual double      SchottyJsp (double      n,
                                double      Tl,
                                double      Vb) = 0
virtual AutoDScalar SchottyJsp (AutoDScalar n,
                                AutoDScalar Tl,
                                AutoDScalar Vb) = 0
\end{lstlisting}
Return the hole current density at Schottky contacts. The argument
$\mathbf{Vb}$ is the
            electron barrier height.
\par
\begin{lstlisting}[language={C++}]
virtual double SchottyBarrierLowerring (double      eps,
                                        double      E) = 0
\end{lstlisting}
Return the total recombination rate of all recombination mechanisms.
\par
\begin{lstlisting}[language={C++}]
virtual double ARichN() = 0
virtual double ARichP() = 0
\end{lstlisting}
Return the Richardson constant for electrons and holes, respectively.
\par
\begin{lstlisting}[language={C++}]
virtual double      ThermalVn (double      Tl) = 0
virtual AutoDScalar ThermalVn (AutoDScalar Tl) = 0
\end{lstlisting}
Return the electron thermal emission velocity at hetero-junctions
\par
\begin{lstlisting}[language={C++}]
virtual double      ThermalVp (double      Tl) = 0
virtual AutoDScalar ThermalVp (AutoDScalar Tl) = 0
\end{lstlisting}
Return the Richardson constant for electrons and holes, respectively.
\par
\begin{lstlisting}[language={C++}]
virtual double      BB_Tunneling(const double      &Tl,
                                 const double      &E) = 0
virtual AutoDScalar BB_Tunneling(const AutoDScalar &Tl,
                                 const AutoDScalar &E) = 0
\end{lstlisting}
Return the band-to-band tunneling generation rate. The argument
$\mathbf{E}$ is the
            magnitude of electric field.
\par
\subsubsection{PMIS\_Mobility}
Unless otherwise stated, the arguments of the following methods are
\par
\begin{compactitem}
\item $\mathbf{p}$ hole concentration
\par
\item $\mathbf{n}$ electron concentration
\par
\item $\mathbf{Tl}$ lattice temperature
\par
\item $\mathbf{Tp}$ hole temperature
\par
\item $\mathbf{Tn}$ electron temperature
\par
\end{compactitem}
\begin{lstlisting}[language={C++}]
virtual double      ElecMob (const double      &p,
                             const double      &n,
                             const double      &Tl,
                             const double      &Ep,
                             const double      &Et,
                             const double      &Tn) const=0
virtual AutoDScalar ElecMob (const AutoDScalar &p,
                             const AutoDScalar &n,
                             const AutoDScalar &Tl,
                             const AutoDScalar &Ep,
                             const AutoDScalar &Et,
                             const AutoDScalar &Tn) const=0
\end{lstlisting}
Return the electron mobility. The argument $\mathbf{Ep}$ and $\mathbf{Et}$
are
            the parallel and transverse components of the electric field, respectively.
\par
\begin{lstlisting}[language={C++}]
virtual double      HoleMob (const double      &p,
                             const double      &n,
                             const double      &Tl,
                             const double      &Ep,
                             const double      &Et,
                             const double      &Tp) const=0
virtual AutoDScalar HoleMob (const AutoDScalar &p,
                             const AutoDScalar &n,
                             const AutoDScalar &Tl,
                             const AutoDScalar &Ep,
                             const AutoDScalar &Et,
                             const AutoDScalar &Tp) const=0
\end{lstlisting}
Return the hole mobility. The argument $\mathbf{Ep}$ and $\mathbf{Et}$
are the
            parallel and transverse components of the electric field, respectively.
\par
\subsubsection{PMIS\_Avalanche}
\label{sec:Extend:PMI:Ref:PMIS:Avalanche}
Unless otherwise stated, the arguments of the following methods are
\par
\begin{compactitem}
\item $\mathbf{Tl}$ lattice temperature
\par
\item $\mathbf{Tp}$ hole temperature
\par
\item $\mathbf{Tn}$ electron temperature
\par
\item $\mathbf{Ep}$ driving force of impact ionization (parallel electric field).
\par
\item $\mathbf{Eg}$ bandgap
\par
\end{compactitem}
\begin{lstlisting}[language={C++}]
virtual double      ElecGenRate (const double      &Tl,
                                 const double      &Ep,
                                 const double      &Eg) const = 0
virtual AutoDScalar ElecGenRate (const AutoDScalar &Tl,
                                 const AutoDScalar &Ep,
                                 const AutoDScalar &Eg) const = 0
\end{lstlisting}
Return the generation rate of electron-initiated impact ionization.
\par
\begin{lstlisting}[language={C++}]
virtual double      HoleGenRate (const double      &Tl,
                                 const double      &Ep,
                                 const double      &Eg) const = 0
virtual AutoDScalar HoleGenRate (const AutoDScalar &Tl,
                                 const AutoDScalar &Ep,
                                 const AutoDScalar &Eg) const = 0
\end{lstlisting}
Return the generation rate of hole-initiated impact ionization.
\par
\begin{lstlisting}[language={C++}]
virtual double      ElecGenRateEBM (const double      &Tn,
                                    const double      &Tl,
                                    const double      &Eg) const = 0
virtual AutoDScalar ElecGenRateEBM (const AutoDScalar &Tn,
                                    const AutoDScalar &Tl,
                                    const AutoDScalar &Eg) const = 0
\end{lstlisting}
Return the generation rate of electron-initiated impact ionization, calculate from the electron
            temperature. Used in EBM simulation only.
\par
\begin{lstlisting}[language={C++}]
virtual double      HoleGenRateEBM (const double      &Tp,
                                    const double      &Tl,
                                    const double      &Eg) const = 0
virtual AutoDScalar HoleGenRateEBM (const AutoDScalar &Tp,
                                    const AutoDScalar &Tl,
                                    const AutoDScalar &Eg) const = 0
\end{lstlisting}
Return the generation rate of hole-initiated impact ionization, calculate from the electron
            temperature. Used in EBM simulation only.
\par
\subsubsection{PMIS\_Trap}
[[TODO]]
\par
\subsubsection{PMIS\_Thermal}
\label{sec:Extend:PMI:Ref:PMIS:Thermal}
The argument Tl is the lattice temperature.
\par
\begin{lstlisting}[language={C++}]
virtual double      HeatCapacity  (const double      &Tl) const = 0
virtual AutoDScalar HeatCapacity  (const AutoDScalar &Tl) const = 0
\end{lstlisting}
Return the heat capacity $JK^{-1}cm^{-3}$ of the
            material.
\par
\begin{lstlisting}[language={C++}]
virtual double      HeatConduction(const double      &Tl) const = 0
virtual AutoDScalar HeatConduction(const AutoDScalar &Tl) const = 0
\end{lstlisting}
Return the heat conduction $W/cm/K$ of the
            material.
\par
\subsubsection{PMIS\_Optical}
\label{sec:Extend:PMI:Ref:PMIS:Optical}
The argument lambda is the wavelength, Eg the
          bandgap, and Tl the lattice temperature.
\par
\begin{lstlisting}[language={C++}]
virtual std::complex<double> RefractionIndex(double lamda,
                                             double Eg,
                                             double Tl) const = 0
\end{lstlisting}
Return the heat capacity $\Joule\Inverse\Kelvin{}cm^{-3}$ of the
            material.
\par
\subsubsection{PMII}
empty
\par
\subsubsection{PMII\_BasicParameter}
See \nameref{sec:Extend:PMI:Ref:PMIS:Basic}, p. \pageref{sec:Extend:PMI:Ref:PMIS:Basic}.
\par
\subsubsection{PMII\_Thermal}
See \nameref{sec:Extend:PMI:Ref:PMIS:Thermal}, p. \pageref{sec:Extend:PMI:Ref:PMIS:Thermal}.
\par
\subsubsection{PMII\_Optical}
See \nameref{sec:Extend:PMI:Ref:PMIS:Optical}, p. \pageref{sec:Extend:PMI:Ref:PMIS:Optical}.
\par
\subsubsection{PMIC}
empty
\par
\subsubsection{PMIC\_BasicParameter}
\begin{lstlisting}[language={C++}]
virtual double Density (const PetscScalar &Tl) const = 0
\end{lstlisting}
Return the mass density $g/cm^{-3}$ of the material.
\par
\begin{lstlisting}[language={C++}]
virtual double Permittivity () const = 0
\end{lstlisting}
Return the relative permittivity of the material.
\par
\begin{lstlisting}[language={C++}]
virtual double Permeability () const = 0
\end{lstlisting}
Return the relative permeability of the material.
\par
\begin{lstlisting}[language={C++}]
virtual double Affinity (const double &Tl) const = 0
\end{lstlisting}
Return the affinity energy [eV] of the material.
\par
\begin{lstlisting}[language={C++}]
virtual double Conductance () const = 0
\end{lstlisting}
Return the electrical conductance of the material.
\par
\par
\subsubsection{PMIC\_Thermal}
See \nameref{sec:Extend:PMI:Ref:PMIS:Thermal}, p. \pageref{sec:Extend:PMI:Ref:PMIS:Thermal}.
\par
\subsubsection{PMIC\_Optical}
See \nameref{sec:Extend:PMI:Ref:PMIS:Optical}, p. \pageref{sec:Extend:PMI:Ref:PMIS:Optical}.
\par
\section{Hooks}
[[TODO]]
\par
\section{Python Interface}
[[TODO]]
\par
\subsection{HTTP Frontend}
[[TODO]]
\par
%\stopbodymatter

\bibliographystyle{plain}
\bibliography{genius_ug}


\printindex{}
\end{document}
